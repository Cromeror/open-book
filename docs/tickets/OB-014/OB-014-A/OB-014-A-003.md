# OB-014-A-003: Implementar Server Actions protegidas

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-A - Autenticacion Server-Side y Proteccion de Rutas |
| Status | done |
| Priority | critical |
| Created | 2026-01-05 |
| Updated | 2026-01-06 |
| Labels | task, frontend, server-actions, permisos, server-first |
| Depends on | OB-014-A-002 |
| Assigned | unassigned |

## Descripcion

Implementar el patron para Server Actions protegidas. Cada Server Action debe verificar permisos antes de ejecutar cualquier operacion. Esto garantiza que las mutaciones (crear, actualizar, eliminar) solo se ejecuten si el usuario tiene los permisos necesarios.

**Server-First**: Las Server Actions son la forma segura de ejecutar mutaciones - NUNCA exponer endpoints directamente al cliente.

## Contexto Tecnico

### Archivos afectados
- `apps/web/src/lib/actions.server.ts` (utilidades para actions)
- `apps/web/src/app/(dashboard)/*/actions.ts` (actions por modulo)

### Enfoque tecnico
Crear wrapper/helper que verifica permisos antes de ejecutar la accion. Usar `revalidatePath` y `revalidateTag` para invalidar cache despues de mutaciones.

## Criterios de Aceptacion

- [ ] Server Actions verifican permisos antes de ejecutar
- [ ] Verifican tanto modulo como permiso granular
- [ ] Verifican scope (copropiedad, own) cuando aplica
- [ ] Retornan error descriptivo si no tiene permiso
- [ ] Usan revalidatePath/revalidateTag para cache
- [ ] Patron reutilizable para todas las actions

## Notas de Implementacion

```typescript
// lib/actions.server.ts
import 'server-only';

import { getServerPermissions, ServerPermissions } from './permissions.server';

// Tipo para resultado de action
export type ActionResult<T> =
  | { success: true; data: T }
  | { success: false; error: string };

/**
 * Wrapper para Server Actions que requieren permiso
 *
 * @example
 * ```ts
 * export const createObjetivo = withPermission(
 *   'objetivos:create',
 *   async (permissions, formData: FormData) => {
 *     // Tu logica aqui
 *     return { id: '...' };
 *   }
 * );
 * ```
 */
export function withPermission<TArgs extends unknown[], TResult>(
  permission: string,
  action: (permissions: ServerPermissions, ...args: TArgs) => Promise<TResult>
) {
  return async (...args: TArgs): Promise<ActionResult<TResult>> => {
    try {
      const permissions = await getServerPermissions();

      if (!permissions.can(permission)) {
        return {
          success: false,
          error: `No tienes permiso para realizar esta accion`,
        };
      }

      const result = await action(permissions, ...args);
      return { success: true, data: result };
    } catch (error) {
      console.error('Action error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error desconocido',
      };
    }
  };
}

/**
 * Wrapper para Server Actions que requieren permiso con scope
 *
 * @example
 * ```ts
 * export const updateObjetivo = withScopedPermission(
 *   'objetivos:update',
 *   (formData) => formData.get('copropiedadId') as string,
 *   async (permissions, formData: FormData) => {
 *     // Tu logica aqui
 *   }
 * );
 * ```
 */
export function withScopedPermission<TArgs extends unknown[], TResult>(
  permission: string,
  getScopeId: (...args: TArgs) => string,
  action: (permissions: ServerPermissions, ...args: TArgs) => Promise<TResult>
) {
  return async (...args: TArgs): Promise<ActionResult<TResult>> => {
    try {
      const permissions = await getServerPermissions();
      const scopeId = getScopeId(...args);

      if (!permissions.canInScope(permission, scopeId)) {
        return {
          success: false,
          error: `No tienes permiso para realizar esta accion en este contexto`,
        };
      }

      const result = await action(permissions, ...args);
      return { success: true, data: result };
    } catch (error) {
      console.error('Action error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error desconocido',
      };
    }
  };
}

/**
 * Wrapper para Server Actions solo SuperAdmin
 */
export function withSuperAdmin<TArgs extends unknown[], TResult>(
  action: (permissions: ServerPermissions, ...args: TArgs) => Promise<TResult>
) {
  return async (...args: TArgs): Promise<ActionResult<TResult>> => {
    try {
      const permissions = await getServerPermissions();

      if (!permissions.isSuperAdmin) {
        return {
          success: false,
          error: 'Solo el SuperAdmin puede realizar esta accion',
        };
      }

      const result = await action(permissions, ...args);
      return { success: true, data: result };
    } catch (error) {
      console.error('Action error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error desconocido',
      };
    }
  };
}

// app/(dashboard)/objetivos/actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { withPermission, withScopedPermission } from '@/lib/actions.server';
import { createObjetivoInDB, updateObjetivoInDB, deleteObjetivoInDB } from '@/lib/db/objetivos';
import { z } from 'zod';

// Schema de validacion
const createObjetivoSchema = z.object({
  nombre: z.string().min(1).max(200),
  descripcion: z.string().optional(),
  montoMeta: z.number().positive(),
  fechaLimite: z.string().datetime(),
  copropiedadId: z.string().uuid(),
});

/**
 * Crear objetivo - requiere objetivos:create
 */
export const createObjetivo = withScopedPermission(
  'objetivos:create',
  (formData: FormData) => formData.get('copropiedadId') as string,
  async (permissions, formData: FormData) => {
    // Validar datos
    const rawData = {
      nombre: formData.get('nombre'),
      descripcion: formData.get('descripcion'),
      montoMeta: Number(formData.get('montoMeta')),
      fechaLimite: formData.get('fechaLimite'),
      copropiedadId: formData.get('copropiedadId'),
    };

    const validated = createObjetivoSchema.parse(rawData);

    // Crear en DB
    const objetivo = await createObjetivoInDB({
      ...validated,
      createdBy: permissions.userId!,
    });

    // Revalidar cache
    revalidatePath('/objetivos');

    return objetivo;
  }
);

/**
 * Actualizar objetivo - requiere objetivos:update
 */
export const updateObjetivo = withScopedPermission(
  'objetivos:update',
  (id: string, formData: FormData) => formData.get('copropiedadId') as string,
  async (permissions, id: string, formData: FormData) => {
    const objetivo = await updateObjetivoInDB(id, {
      nombre: formData.get('nombre') as string,
      descripcion: formData.get('descripcion') as string,
      updatedBy: permissions.userId!,
    });

    revalidatePath('/objetivos');
    revalidatePath(`/objetivos/${id}`);

    return objetivo;
  }
);

/**
 * Eliminar objetivo - requiere objetivos:delete
 */
export const deleteObjetivo = withScopedPermission(
  'objetivos:delete',
  async (id: string) => {
    // Cargar objetivo para obtener copropiedadId
    const objetivo = await getObjetivoById(id);
    return objetivo.copropiedadId;
  },
  async (permissions, id: string) => {
    await deleteObjetivoInDB(id);

    revalidatePath('/objetivos');

    return { deleted: true };
  }
);
```

## Uso en Client Components

```typescript
// components/objetivos/create-form.tsx
'use client';

import { useTransition } from 'react';
import { createObjetivo } from '@/app/(dashboard)/objetivos/actions';
import { toast } from 'sonner';

export function CreateObjetivoForm({ copropiedadId }: { copropiedadId: string }) {
  const [isPending, startTransition] = useTransition();

  const handleSubmit = async (formData: FormData) => {
    formData.set('copropiedadId', copropiedadId);

    startTransition(async () => {
      const result = await createObjetivo(formData);

      if (result.success) {
        toast.success('Objetivo creado exitosamente');
        // El revalidatePath ya actualiza la UI automaticamente
      } else {
        toast.error(result.error);
      }
    });
  };

  return (
    <form action={handleSubmit}>
      <input name="nombre" required />
      <textarea name="descripcion" />
      <input name="montoMeta" type="number" required />
      <input name="fechaLimite" type="datetime-local" required />

      <button type="submit" disabled={isPending}>
        {isPending ? 'Creando...' : 'Crear Objetivo'}
      </button>
    </form>
  );
}
```

## Patrones Importantes

### 1. Siempre verificar permisos primero
```typescript
// ✅ Correcto
export const myAction = withPermission('modulo:accion', async (perms, data) => {
  // La verificacion ya se hizo
});

// ❌ Incorrecto - No hacer verificacion manual parcial
export async function myAction(data: FormData) {
  // Esto puede olvidarse!
  const perms = await getServerPermissions();
  if (!perms.can('...')) throw new Error('...');
}
```

### 2. Usar scope cuando aplica
```typescript
// Para acciones que dependen de copropiedad
export const updateAporte = withScopedPermission(
  'aportes:update',
  (id, formData) => formData.get('copropiedadId') as string,
  async (perms, id, formData) => { ... }
);
```

### 3. Revalidar cache despues de mutaciones
```typescript
revalidatePath('/objetivos');        // Revalida ruta especifica
revalidatePath('/objetivos/[id]');   // Revalida rutas dinamicas
revalidateTag('objetivos');          // Revalida por tag
```

## Testing

- [ ] withPermission verifica permiso antes de ejecutar
- [ ] withScopedPermission verifica scope
- [ ] withSuperAdmin solo permite SuperAdmin
- [ ] Retorna error descriptivo si no tiene permiso
- [ ] revalidatePath se llama despues de mutacion
- [ ] Validacion de datos funciona correctamente
