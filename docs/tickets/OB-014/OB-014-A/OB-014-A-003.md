# OB-014-A-003: Implementar Server Actions protegidas

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-A - Autenticacion Server-Side y Proteccion de Rutas |
| Status | done |
| Priority | critical |
| Created | 2026-01-05 |
| Updated | 2026-01-06 |
| Labels | task, frontend, server-actions, permisos, server-first |
| Depends on | OB-014-A-002 |
| Assigned | unassigned |

## Descripcion

Implementar el patron para Server Actions protegidas. Cada Server Action debe verificar permisos antes de ejecutar cualquier operacion. Esto garantiza que las mutaciones (crear, actualizar, eliminar) solo se ejecuten si el usuario tiene los permisos necesarios.

**Server-First**: Las Server Actions son la forma segura de ejecutar mutaciones - NUNCA exponer endpoints directamente al cliente.

## Contexto Tecnico

### Archivos afectados
- `apps/web/src/lib/actions.server.ts` (utilidades para actions)
- `apps/web/src/app/(dashboard)/*/actions.ts` (actions por modulo)

### Enfoque tecnico
Crear wrapper/helper que verifica permisos antes de ejecutar la accion. Usar `revalidatePath` y `revalidateTag` para invalidar cache despues de mutaciones.

## Criterios de Aceptacion

- [ ] Server Actions verifican permisos antes de ejecutar
- [ ] Verifican tanto modulo como permiso granular
- [ ] Verifican scope (copropiedad, own) cuando aplica
- [ ] Retornan error descriptivo si no tiene permiso
- [ ] Usan revalidatePath/revalidateTag para cache
- [ ] Patron reutilizable para todas las actions

## Notas de Implementacion

```typescript
// lib/actions.server.ts
import 'server-only';

import { getServerPermissions, ServerPermissions } from './permissions.server';

// Tipo para resultado de action
export type ActionResult<T> =
  | { success: true; data: T }
  | { success: false; error: string };

/**
 * Wrapper para Server Actions que requieren permiso
 *
 * @example
 * ```ts
 * export const createObjetivo = withPermission(
 *   'objetivos:create',
 *   async (permissions, formData: FormData) => {
 *     // Tu logica aqui
 *     return { id: '...' };
 *   }
 * );
 * ```
 */
export function withPermission<TArgs extends unknown[], TResult>(
  permission: string,
  action: (permissions: ServerPermissions, ...args: TArgs) => Promise<TResult>
) {
  return async (...args: TArgs): Promise<ActionResult<TResult>> => {
    try {
      const permissions = await getServerPermissions();

      if (!permissions.can(permission)) {
        return {
          success: false,
          error: `No tienes permiso para realizar esta accion`,
        };
      }

      const result = await action(permissions, ...args);
      return { success: true, data: result };
    } catch (error) {
      console.error('Action error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error desconocido',
      };
    }
  };
}

/**
 * Wrapper para Server Actions que requieren permiso con scope
 *
 * @example
 * ```ts
 * export const updateObjetivo = withScopedPermission(
 *   'objetivos:update',
 *   (formData) => formData.get('copropiedadId') as string,
 *   async (permissions, formData: FormData) => {
 *     // Tu logica aqui
 *   }
 * );
 * ```
 */
export function withScopedPermission<TArgs extends unknown[], TResult>(
  permission: string,
  getScopeId: (...args: TArgs) => string,
  action: (permissions: ServerPermissions, ...args: TArgs) => Promise<TResult>
) {
  return async (...args: TArgs): Promise<ActionResult<TResult>> => {
    try {
      const permissions = await getServerPermissions();
      const scopeId = getScopeId(...args);

      if (!permissions.canInScope(permission, scopeId)) {
        return {
          success: false,
          error: `No tienes permiso para realizar esta accion en este contexto`,
        };
      }

      const result = await action(permissions, ...args);
      return { success: true, data: result };
    } catch (error) {
      console.error('Action error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error desconocido',
      };
    }
  };
}

/**
 * Wrapper para Server Actions solo SuperAdmin
 */
export function withSuperAdmin<TArgs extends unknown[], TResult>(
  action: (permissions: ServerPermissions, ...args: TArgs) => Promise<TResult>
) {
  return async (...args: TArgs): Promise<ActionResult<TResult>> => {
    try {
      const permissions = await getServerPermissions();

      if (!permissions.isSuperAdmin) {
        return {
          success: false,
          error: 'Solo el SuperAdmin puede realizar esta accion',
        };
      }

      const result = await action(permissions, ...args);
      return { success: true, data: result };
    } catch (error) {
      console.error('Action error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error desconocido',
      };
    }
  };
}

// app/(dashboard)/goals/actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { withPermission, withScopedPermission } from '@/lib/actions.server';
import { createGoalInDB, updateGoalInDB, deleteGoalInDB } from '@/lib/db/goals';
import { z } from 'zod';

// Schema de validacion
const createGoalSchema = z.object({
  name: z.string().min(1).max(200),
  description: z.string().optional(),
  targetAmount: z.number().positive(),
  deadline: z.string().datetime(),
  propertyId: z.string().uuid(),
});

/**
 * Crear objetivo - requiere goals:create
 */
export const createGoal = withScopedPermission(
  'goals:create',
  (formData: FormData) => formData.get('propertyId') as string,
  async (permissions, formData: FormData) => {
    // Validar datos
    const rawData = {
      name: formData.get('name'),
      description: formData.get('description'),
      targetAmount: Number(formData.get('targetAmount')),
      deadline: formData.get('deadline'),
      propertyId: formData.get('propertyId'),
    };

    const validated = createGoalSchema.parse(rawData);

    // Crear en DB
    const goal = await createGoalInDB({
      ...validated,
      createdBy: permissions.userId!,
    });

    // Revalidar cache
    revalidatePath('/goals');

    return goal;
  }
);

/**
 * Actualizar objetivo - requiere goals:update
 */
export const updateGoal = withScopedPermission(
  'goals:update',
  (id: string, formData: FormData) => formData.get('propertyId') as string,
  async (permissions, id: string, formData: FormData) => {
    const goal = await updateGoalInDB(id, {
      name: formData.get('name') as string,
      description: formData.get('description') as string,
      updatedBy: permissions.userId!,
    });

    revalidatePath('/goals');
    revalidatePath(`/goals/${id}`);

    return goal;
  }
);

/**
 * Eliminar objetivo - requiere goals:delete
 */
export const deleteGoal = withScopedPermission(
  'goals:delete',
  async (id: string) => {
    // Cargar objetivo para obtener propertyId
    const goal = await getGoalById(id);
    return goal.propertyId;
  },
  async (permissions, id: string) => {
    await deleteGoalInDB(id);

    revalidatePath('/goals');

    return { deleted: true };
  }
);
```

## Uso en Client Components

```typescript
// components/goals/create-form.tsx
'use client';

import { useTransition } from 'react';
import { createGoal } from '@/app/(dashboard)/goals/actions';
import { toast } from 'sonner';

export function CreateGoalForm({ propertyId }: { propertyId: string }) {
  const [isPending, startTransition] = useTransition();

  const handleSubmit = async (formData: FormData) => {
    formData.set('propertyId', propertyId);

    startTransition(async () => {
      const result = await createGoal(formData);

      if (result.success) {
        toast.success('Objetivo creado exitosamente');
        // El revalidatePath ya actualiza la UI automaticamente
      } else {
        toast.error(result.error);
      }
    });
  };

  return (
    <form action={handleSubmit}>
      <input name="name" required />
      <textarea name="description" />
      <input name="targetAmount" type="number" required />
      <input name="deadline" type="datetime-local" required />

      <button type="submit" disabled={isPending}>
        {isPending ? 'Creando...' : 'Crear Objetivo'}
      </button>
    </form>
  );
}
```

## Patrones Importantes

### 1. Siempre verificar permisos primero
```typescript
// ✅ Correcto
export const myAction = withPermission('modulo:accion', async (perms, data) => {
  // La verificacion ya se hizo
});

// ❌ Incorrecto - No hacer verificacion manual parcial
export async function myAction(data: FormData) {
  // Esto puede olvidarse!
  const perms = await getServerPermissions();
  if (!perms.can('...')) throw new Error('...');
}
```

### 2. Usar scope cuando aplica
```typescript
// Para acciones que dependen de copropiedad
export const updateContribution = withScopedPermission(
  'contributions:update',
  (id, formData) => formData.get('propertyId') as string,
  async (perms, id, formData) => { ... }
);
```

### 3. Revalidar cache despues de mutaciones
```typescript
revalidatePath('/goals');        // Revalida ruta especifica
revalidatePath('/goals/[id]');   // Revalida rutas dinamicas
revalidateTag('goals');          // Revalida por tag
```

## Testing

- [ ] withPermission verifica permiso antes de ejecutar
- [ ] withScopedPermission verifica scope
- [ ] withSuperAdmin solo permite SuperAdmin
- [ ] Retorna error descriptivo si no tiene permiso
- [ ] revalidatePath se llama despues de mutacion
- [ ] Validacion de datos funciona correctamente
