# OB-014-A-001: Crear AuthContext y AuthProvider

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Rol de Usuario |
| Story | OB-014-A - Contexto de autenticacion y proteccion de rutas |
| Status | pending |
| Priority | critical |
| Created | 2026-01-05 |
| Updated | 2026-01-05 |
| Labels | task, frontend, context, auth |
| Depends on | OB-002-B-001 |
| Assigned | unassigned |

## Descripcion

Crear el contexto de React para manejar el estado de autenticacion global de la aplicacion, incluyendo informacion del usuario, rol, y funciones de login/logout.

## Contexto Tecnico

### Archivos afectados
- `apps/web/src/contexts/AuthContext.tsx`
- `apps/web/src/app/layout.tsx` (envolver con provider)
- `apps/web/src/types/auth.ts`

### Enfoque tecnico
Implementar React Context con TypeScript tipado. El provider debe manejar la persistencia del token y la rehidratacion del estado al cargar la pagina.

## Criterios de Aceptacion

- [ ] AuthContext creado con TypeScript
- [ ] AuthProvider envuelve la aplicacion
- [ ] Estado incluye: user, isAuthenticated, isLoading, role
- [ ] Funciones: login, logout, refreshToken
- [ ] Persistencia de sesion entre recargas
- [ ] Manejo de estado de carga inicial

## Notas de Implementacion

```typescript
// types/auth.ts
export enum Role {
  ADMIN = 'ADMIN',
  RESIDENT = 'RESIDENT',
}

export interface User {
  id: string;
  email: string;
  nombre: string;
  apellido: string;
  role: Role;
}

export interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
}

// contexts/AuthContext.tsx
'use client';

import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { AuthContextType, User } from '@/types/auth';

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Verificar sesion existente al cargar
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      // Llamar a /api/auth/me para verificar token
      const response = await fetch('/api/auth/me');
      if (response.ok) {
        const userData = await response.json();
        setUser(userData);
      }
    } catch {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({ email, password }),
    });
    if (!response.ok) throw new Error('Login failed');
    const { user } = await response.json();
    setUser(user);
  };

  const logout = () => {
    fetch('/api/auth/logout', { method: 'POST' });
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{
      user,
      isAuthenticated: !!user,
      isLoading,
      login,
      logout,
      refreshToken: checkAuth,
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuthContext = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuthContext must be used within AuthProvider');
  return context;
};
```

## Testing

- [ ] AuthProvider renderiza children correctamente
- [ ] Login actualiza el estado del usuario
- [ ] Logout limpia el estado
- [ ] Estado de carga funciona durante verificacion inicial
