# OB-014-A-004: Crear componentes de permisos (server y client)

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-A - Autenticacion Server-Side y Proteccion de Rutas |
| Status | done |
| Priority | high |
| Created | 2026-01-05 |
| Updated | 2026-01-06 |
| Labels | task, frontend, components, permisos, server-first |
| Depends on | OB-014-A-002 |
| Assigned | unassigned |

## Descripcion

Crear componentes para renderizado condicional basado en permisos. Los Server Components verifican permisos en el servidor, mientras que los Client Components reciben flags de permisos como props (ya verificados en el servidor).

**Server-First Principle:**
- Los Server Components verifican permisos usando `getServerPermissions()`
- Los Client Components NUNCA verifican permisos - solo reciben booleans (`canEdit`, `canDelete`)
- La decision de mostrar/ocultar se toma en el servidor

## Contexto Tecnico

### Archivos afectados
- `apps/web/src/components/server/permissions/` (Server Components)
- `apps/web/src/components/ui/` (Client Components reciben props)

### Enfoque tecnico
Server Components para renderizado condicional. Client Components reciben props de permisos pre-calculados.

## Criterios de Aceptacion

- [ ] Server Components para renderizado condicional por modulo/permiso
- [ ] Patron claro para pasar permisos a Client Components
- [ ] No exponer logica de permisos al cliente
- [ ] Loading states apropiados
- [ ] Documentacion de patrones de uso

## Notas de Implementacion

### Server Components de Permisos

```typescript
// components/server/permissions/show-for-module.tsx
// Este es un Server Component (sin 'use client')
import { getServerPermissions } from '@/lib/permissions.server';
import { ReactNode } from 'react';

interface ShowForModuleProps {
  module: string;
  children: ReactNode;
  fallback?: ReactNode;
}

/**
 * Server Component que renderiza children solo si tiene acceso al modulo
 *
 * @example
 * ```tsx
 * <ShowForModule module="goals">
 *   <GoalsSection />
 * </ShowForModule>
 * ```
 */
export async function ShowForModule({
  module,
  children,
  fallback = null,
}: ShowForModuleProps) {
  const permissions = await getServerPermissions();

  if (!permissions.hasModule(module)) {
    return <>{fallback}</>;
  }

  return <>{children}</>;
}

// components/server/permissions/show-for-permission.tsx
import { getServerPermissions } from '@/lib/permissions.server';
import { ReactNode } from 'react';

interface ShowForPermissionProps {
  permission: string;
  children: ReactNode;
  fallback?: ReactNode;
}

/**
 * Server Component que renderiza children solo si tiene el permiso
 *
 * @example
 * ```tsx
 * <ShowForPermission permission="goals:create">
 *   <CreateButton />
 * </ShowForPermission>
 * ```
 */
export async function ShowForPermission({
  permission,
  children,
  fallback = null,
}: ShowForPermissionProps) {
  const permissions = await getServerPermissions();

  if (!permissions.can(permission)) {
    return <>{fallback}</>;
  }

  return <>{children}</>;
}

// components/server/permissions/show-for-superadmin.tsx
import { getServerPermissions } from '@/lib/permissions.server';
import { ReactNode } from 'react';

interface ShowForSuperAdminProps {
  children: ReactNode;
  fallback?: ReactNode;
}

/**
 * Server Component que renderiza children solo para SuperAdmin
 */
export async function ShowForSuperAdmin({
  children,
  fallback = null,
}: ShowForSuperAdminProps) {
  const permissions = await getServerPermissions();

  if (!permissions.isSuperAdmin) {
    return <>{fallback}</>;
  }

  return <>{children}</>;
}

// components/server/permissions/index.ts
export { ShowForModule } from './show-for-module';
export { ShowForPermission } from './show-for-permission';
export { ShowForSuperAdmin } from './show-for-superadmin';
```

### Patron para Client Components

```typescript
// ❌ INCORRECTO - No hacer esto (verificar permisos en cliente)
// components/client/goals-list.tsx
'use client';

import { usePermissions } from '@/hooks/usePermissions'; // NO!

export function GoalsList({ goals }) {
  const { can } = usePermissions(); // ❌ Verificar en cliente es inseguro

  return (
    <ul>
      {goals.map(goal => (
        <li key={goal.id}>
          {goal.name}
          {can('goals:delete') && <DeleteButton />} // ❌ INSEGURO
        </li>
      ))}
    </ul>
  );
}

// ✅ CORRECTO - Recibir permisos como props desde Server Component
// components/client/goals-list.tsx
'use client';

interface GoalsListProps {
  goals: Goal[];
  canUpdate: boolean;  // Pre-calculado en servidor
  canDelete: boolean;  // Pre-calculado en servidor
}

export function GoalsList({
  goals,
  canUpdate,
  canDelete,
}: GoalsListProps) {
  return (
    <ul>
      {goals.map(goal => (
        <li key={goal.id}>
          {goal.name}
          {canUpdate && <EditButton id={goal.id} />}
          {canDelete && <DeleteButton id={goal.id} />}
        </li>
      ))}
    </ul>
  );
}

// app/(dashboard)/goals/page.tsx (Server Component)
import { redirect } from 'next/navigation';
import { getServerPermissions } from '@/lib/permissions.server';
import { GoalsList } from '@/components/client/goals-list';

export default async function GoalsPage() {
  const permissions = await getServerPermissions();

  // Verificacion en servidor
  if (!permissions.hasModule('goals')) {
    redirect('/acceso-denegado');
  }

  const goals = await fetchGoals();

  // Pasar permisos PRE-CALCULADOS al cliente
  return (
    <GoalsList
      goals={goals}
      canUpdate={permissions.can('goals:update')}
      canDelete={permissions.can('goals:delete')}
    />
  );
}
```

### Helper para Props de Permisos

```typescript
// lib/permissions.helpers.ts

/**
 * Crea un objeto con props de permisos para pasar a Client Components
 *
 * @example
 * ```tsx
 * const permissionProps = createPermissionProps(permissions, {
 *   canUpdate: 'goals:update',
 *   canDelete: 'goals:delete',
 *   canExport: 'goals:export',
 * });
 *
 * return <ClientComponent {...permissionProps} />;
 * ```
 */
export function createPermissionProps<T extends Record<string, string>>(
  permissions: ServerPermissions,
  mapping: T
): Record<keyof T, boolean> {
  const result = {} as Record<keyof T, boolean>;

  for (const [key, permission] of Object.entries(mapping)) {
    result[key as keyof T] = permissions.can(permission);
  }

  return result;
}

// Uso en Server Component
const permissionProps = createPermissionProps(permissions, {
  canCreate: 'goals:create',
  canUpdate: 'goals:update',
  canDelete: 'goals:delete',
});

return <GoalsList goals={goals} {...permissionProps} />;
```

### Componente Wrapper para Acciones

```typescript
// components/client/action-button.tsx
'use client';

import { ReactNode } from 'react';
import { Button } from '@/components/ui/button';

interface ActionButtonProps {
  /** Si true, el boton se muestra. Si false, no se renderiza. */
  allowed: boolean;
  children: ReactNode;
  onClick?: () => void;
  variant?: 'default' | 'destructive' | 'outline';
  disabled?: boolean;
}

/**
 * Boton que se muestra solo si `allowed` es true
 * El permiso ya fue verificado en el servidor
 */
export function ActionButton({
  allowed,
  children,
  onClick,
  variant = 'default',
  disabled,
}: ActionButtonProps) {
  if (!allowed) {
    return null;
  }

  return (
    <Button variant={variant} onClick={onClick} disabled={disabled}>
      {children}
    </Button>
  );
}
```

## Patrones de Uso

### 1. Pagina completa protegida (Server Component)
```tsx
// app/(dashboard)/goals/page.tsx
import { redirect } from 'next/navigation';
import { getServerPermissions } from '@/lib/permissions.server';

export default async function Page() {
  const permissions = await getServerPermissions();

  if (!permissions.hasModule('goals')) {
    redirect('/acceso-denegado');
  }

  // Si llega aqui, tiene acceso
  return <PageContent />;
}
```

### 2. Seccion condicional (Server Component)
```tsx
// Dentro de un Server Component
import { ShowForPermission } from '@/components/server/permissions';

export default async function Page() {
  return (
    <div>
      <h1>Dashboard</h1>

      <ShowForPermission permission="reports:export">
        <ExportSection />
      </ShowForPermission>
    </div>
  );
}
```

### 3. Lista con acciones condicionales
```tsx
// Server Component pasa props a Client Component
export default async function Page() {
  const permissions = await getServerPermissions();
  const items = await fetchItems();

  return (
    <ItemsList
      items={items}
      canEdit={permissions.can('items:update')}
      canDelete={permissions.can('items:delete')}
    />
  );
}
```

## Por que NO usar Guards en Cliente?

Los Guards de cliente (`'use client'`) que verifican permisos tienen problemas:

1. **Inseguro**: El usuario puede manipular el estado
2. **Flash de contenido**: Se muestra brevemente antes de ocultar
3. **Datos ya enviados**: Los datos llegan al cliente aunque no tenga permiso
4. **Doble carga**: Primero renderiza en servidor, luego verifica en cliente

**Server Components resuelven todo esto** - la verificacion ocurre ANTES de enviar cualquier dato.

## Testing

- [ ] ShowForModule renderiza solo si tiene modulo
- [ ] ShowForPermission renderiza solo si tiene permiso
- [ ] ShowForSuperAdmin renderiza solo para SuperAdmin
- [ ] Client Components reciben props correctamente
- [ ] No hay logica de permisos en Client Components
- [ ] createPermissionProps genera objeto correcto
- [ ] ActionButton respeta prop `allowed`
