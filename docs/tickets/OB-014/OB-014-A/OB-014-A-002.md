# OB-014-A-002: Crear utilidades de permisos server-side

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-A - Autenticacion Server-Side y Proteccion de Rutas |
| Status | done |
| Priority | critical |
| Created | 2026-01-05 |
| Updated | 2026-01-06 |
| Labels | task, frontend, server, permisos, server-first |
| Depends on | OB-014-A-001, OB-002-C |
| Assigned | unassigned |

## Descripcion

Crear las utilidades de permisos que se ejecutan exclusivamente en el servidor (Server Components, Server Actions). Estas funciones cargan los permisos del usuario desde el backend y proveen metodos para verificar acceso a modulos y permisos granulares.

**Server-First**: Estas utilidades SOLO funcionan en el servidor. No deben importarse en Client Components.

## Contexto Tecnico

### Archivos afectados
- `apps/web/src/lib/permissions.server.ts` (SERVER ONLY)
- `apps/web/src/lib/api.server.ts` (SERVER ONLY)
- `apps/web/src/types/permissions.ts`

### Enfoque tecnico
Usar `cookies()` de `next/headers` para obtener el token y hacer fetch al backend para cargar permisos. Cachear resultados con `unstable_cache` para reducir llamadas.

## Criterios de Aceptacion

- [ ] getServerPermissions() disponible para Server Components
- [ ] Carga permisos desde GET /api/auth/me
- [ ] SuperAdmin tiene acceso total sin queries adicionales
- [ ] hasModule() verifica acceso a modulo
- [ ] can() verifica permiso granular
- [ ] canInScope() verifica permiso con scope
- [ ] Cache de permisos para reducir llamadas al backend
- [ ] Funciona solo en servidor (error si se importa en cliente)

## Notas de Implementacion

```typescript
// lib/permissions.server.ts
// ⚠️ Este archivo SOLO debe usarse en Server Components/Actions
import 'server-only'; // Previene importacion en cliente

import { cookies } from 'next/headers';
import { cache } from 'react';
import { verifyToken } from './auth';
import { fetchUserPermissionsFromAPI } from './api.server';

// Tipos
export interface Permission {
  module: string;
  action: string;
  scope: 'own' | 'copropiedad' | 'all';
  scopeId?: string;
}

export interface ServerPermissions {
  userId: string | null;
  isSuperAdmin: boolean;
  isAuthenticated: boolean;
  modules: string[];
  permissions: Permission[];
  hasModule: (module: string) => boolean;
  can: (permission: string) => boolean;
  canInScope: (permission: string, scopeId: string) => boolean;
  canAny: (permissions: string[]) => boolean;
  canAll: (permissions: string[]) => boolean;
}

// Lista de todos los modulos (para SuperAdmin)
const ALL_MODULES = [
  'users', 'properties', 'apartments', 'goals',
  'activities', 'commitments', 'contributions', 'pqr',
  'reports', 'audit', 'notifications', 'settings',
];

/**
 * Crea objeto de permisos vacio (usuario no autenticado)
 */
function createEmptyPermissions(): ServerPermissions {
  return {
    userId: null,
    isSuperAdmin: false,
    isAuthenticated: false,
    modules: [],
    permissions: [],
    hasModule: () => false,
    can: () => false,
    canInScope: () => false,
    canAny: () => false,
    canAll: () => false,
  };
}

/**
 * Crea objeto de permisos para SuperAdmin (acceso total)
 */
function createSuperAdminPermissions(userId: string): ServerPermissions {
  return {
    userId,
    isSuperAdmin: true,
    isAuthenticated: true,
    modules: ALL_MODULES,
    permissions: [],
    hasModule: () => true,
    can: () => true,
    canInScope: () => true,
    canAny: () => true,
    canAll: () => true,
  };
}

/**
 * Crea objeto de permisos para usuario regular
 */
function createUserPermissions(
  userId: string,
  modules: string[],
  permissions: Permission[]
): ServerPermissions {
  return {
    userId,
    isSuperAdmin: false,
    isAuthenticated: true,
    modules,
    permissions,

    hasModule: (module: string) => modules.includes(module),

    can: (permission: string) => {
      const [mod, action] = permission.split(':');
      // Primero verificar acceso al modulo
      if (!modules.includes(mod)) return false;
      // Luego verificar permiso granular
      return permissions.some(p => p.module === mod && p.action === action);
    },

    canInScope: (permission: string, scopeId: string) => {
      const [mod, action] = permission.split(':');
      if (!modules.includes(mod)) return false;

      const perm = permissions.find(p => p.module === mod && p.action === action);
      if (!perm) return false;

      // Verificar scope
      if (perm.scope === 'all') return true;
      if (perm.scope === 'property') return perm.scopeId === scopeId;
      // 'own' scope se valida comparando con el recurso (en el servicio)
      return perm.scope === 'own';
    },

    canAny: (perms: string[]) => perms.some(p => {
      const [mod, action] = p.split(':');
      if (!modules.includes(mod)) return false;
      return permissions.some(pm => pm.module === mod && pm.action === action);
    }),

    canAll: (perms: string[]) => perms.every(p => {
      const [mod, action] = p.split(':');
      if (!modules.includes(mod)) return false;
      return permissions.some(pm => pm.module === mod && pm.action === action);
    }),
  };
}

/**
 * Obtiene permisos del usuario actual (Server-Side)
 *
 * Usa React cache() para deduplicar llamadas en el mismo request
 *
 * @example
 * ```tsx
 * // En un Server Component
 * export default async function Page() {
 *   const permissions = await getServerPermissions();
 *
 *   if (!permissions.hasModule('objetivos')) {
 *     redirect('/acceso-denegado');
 *   }
 *
 *   return <div>...</div>;
 * }
 * ```
 */
export const getServerPermissions = cache(async (): Promise<ServerPermissions> => {
  const cookieStore = await cookies();
  const token = cookieStore.get('access_token')?.value;

  if (!token) {
    return createEmptyPermissions();
  }

  const payload = await verifyToken(token);
  if (!payload) {
    return createEmptyPermissions();
  }

  // SuperAdmin tiene acceso total - no necesita cargar permisos
  if (payload.isSuperAdmin) {
    return createSuperAdminPermissions(payload.sub);
  }

  // Usuario regular - cargar permisos desde backend
  try {
    const { modules, permissions } = await fetchUserPermissionsFromAPI(token);
    return createUserPermissions(payload.sub, modules, permissions);
  } catch (error) {
    console.error('Error loading permissions:', error);
    return createEmptyPermissions();
  }
});

/**
 * HOF para verificar modulo antes de ejecutar
 */
export async function requireModule(module: string): Promise<ServerPermissions> {
  const permissions = await getServerPermissions();

  if (!permissions.hasModule(module)) {
    const { redirect } = await import('next/navigation');
    redirect('/acceso-denegado');
  }

  return permissions;
}

/**
 * HOF para verificar permiso antes de ejecutar
 */
export async function requirePermission(permission: string): Promise<ServerPermissions> {
  const permissions = await getServerPermissions();

  if (!permissions.can(permission)) {
    const { redirect } = await import('next/navigation');
    redirect('/acceso-denegado');
  }

  return permissions;
}

// lib/api.server.ts
import 'server-only';

const API_URL = process.env.API_URL || 'http://localhost:3001';

export interface UserPermissionsResponse {
  modules: string[];
  permissions: Permission[];
}

export async function fetchUserPermissionsFromAPI(
  token: string
): Promise<UserPermissionsResponse> {
  const response = await fetch(`${API_URL}/api/auth/me`, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
    // Cache por 60 segundos
    next: { revalidate: 60 },
  });

  if (!response.ok) {
    throw new Error('Failed to fetch permissions');
  }

  const data = await response.json();
  return {
    modules: data.modules || [],
    permissions: data.permissions || [],
  };
}
```

## Uso en Server Components

```typescript
// app/(dashboard)/goals/page.tsx
import { redirect } from 'next/navigation';
import { getServerPermissions } from '@/lib/permissions.server';

export default async function GoalsPage() {
  const permissions = await getServerPermissions();

  // Verificar acceso al modulo
  if (!permissions.hasModule('goals')) {
    redirect('/acceso-denegado');
  }

  // Cargar datos solo si tiene permiso
  const goals = await fetchGoals();

  return (
    <div>
      <h1>Objetivos</h1>

      {/* Renderizado condicional en servidor */}
      {permissions.can('goals:create') && (
        <CreateButton />
      )}

      {/* Pasar solo datos necesarios al cliente */}
      <GoalsList
        goals={goals}
        canUpdate={permissions.can('goals:update')}
        canDelete={permissions.can('goals:delete')}
      />
    </div>
  );
}
```

## Testing

- [ ] getServerPermissions() retorna permisos vacios sin token
- [ ] getServerPermissions() retorna SuperAdmin si isSuperAdmin=true
- [ ] hasModule() verifica modulos correctamente
- [ ] can() verifica permiso granular
- [ ] canInScope() verifica scope correctamente
- [ ] cache() deduplica llamadas en mismo request
- [ ] Error al importar en Client Component (server-only)
