# OB-014-E-002: Implementar ModuleRegistry en frontend

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-E - Sistema de Permisos Gobernado por Backend |
| Status | done |
| Priority | high |
| Created | 2026-01-06 |
| Updated | 2026-01-06 |
| Labels | task, frontend, modules, registry |
| Depends on | OB-014-E-001 |

## Descripcion

Implementar un sistema de registro de modulos especializados (NO CRUD) en el frontend. Estos modulos:

1. **Se desarrollan en frontend** - Son componentes React compilados en el bundle
2. **Se registran via admin web** - El SuperAdmin los registra desde la interfaz de administracion
3. **Son asignables a usuarios** - Una vez registrados, pueden asignarse permisos a usuarios
4. **Comparten estructura con CRUD** - La metadata tiene la misma estructura que los modulos CRUD

## Flujo de Modulos Especializados

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DESARROLLO Y REGISTRO                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. Desarrollador crea componente en frontend                       │
│     └─> apps/web/src/modules/reports/ReportsModule.tsx              │
│                                                                      │
│  2. Desarrollador registra en ModuleRegistry (codigo)               │
│     └─> moduleRegistry.registerComponent('reportes', ReportsModule) │
│                                                                      │
│  3. Deploy de nueva version (incluye componente compilado)          │
│                                                                      │
│  4. SuperAdmin registra modulo en backend via UI                    │
│     └─> Admin > Modulos > Registrar Modulo Especializado            │
│     └─> Selecciona de lista de componentes disponibles              │
│                                                                      │
│  5. SuperAdmin asigna permisos a usuarios/roles                     │
│     └─> Admin > Permisos > Asignar modulo a usuario                 │
│                                                                      │
│  6. Usuario ve modulo en navegacion                                 │
│     └─> /api/auth/me retorna modulo con metadata                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

## Estructura de Archivos

```
apps/web/src/lib/
├── module-registry.ts          # Singleton del registro
├── module-registry.context.tsx # React Context y Provider
└── types/
    └── modules.ts              # Tipos de modulos (interfaces, no unions)

apps/web/src/modules/           # Modulos especializados compilados
├── reports/
│   ├── index.ts
│   └── ReportsModule.tsx
├── audit/
│   ├── index.ts
│   └── AuditModule.tsx
├── settings/
│   ├── index.ts
│   └── SettingsModule.tsx
└── index.ts                    # Registro de todos los componentes
```

## Implementacion

### 1. Tipos (apps/web/src/lib/types/modules.ts)

```typescript
// Estructura UNIFICADA para CRUD y especializados
// El codigo de accion coincide con el codigo de permiso

export interface ModuleWithPermissions {
  code: string;
  label: string;
  description: string;
  icon: string;
  type: 'crud' | 'specialized';
  nav: {
    path: string;
    order: number;
  };

  // Config base para modulos CRUD
  entity?: string;                 // 'Objetivo' (solo CRUD)
  endpoint?: string;               // '/api/goals' (solo CRUD)

  // Config para modulos especializados
  component?: string;              // 'ReportsModule' (solo specialized)

  // ACCIONES - Unificado para CRUD y specialized
  // Solo se incluyen las acciones que el usuario tiene permiso
  actions: ModuleAction[];
}

// Accion del modulo - el codigo coincide con el codigo de permiso
export interface ModuleAction {
  code: string;                    // 'read', 'create', 'view', 'export', etc.
  label: string;                   // 'Ver', 'Crear', 'Exportar'
  description?: string;            // 'Permite ver registros'
  settings: ActionSettings;        // Tipado segun tipo de accion
}

// ============================================
// Settings tipados para acciones CRUD
// ============================================

export type ActionSettings = CrudActionSettings | GenericActionSettings;

export type CrudActionSettings =
  | ReadActionSettings
  | CreateActionSettings
  | UpdateActionSettings
  | DeleteActionSettings;

export interface ReadActionSettings {
  type: 'read';
  listColumns: ColumnDefinition[];
  filters?: FilterDefinition[];
  sortable?: string[];
  defaultSort?: { field: string; order: 'asc' | 'desc' };
}

export interface CreateActionSettings {
  type: 'create';
  fields: FieldDefinition[];
  validation?: ValidationRules;
}

export interface UpdateActionSettings {
  type: 'update';
  fields: FieldDefinition[];
  validation?: ValidationRules;
}

export interface DeleteActionSettings {
  type: 'delete';
  confirmation: string;
  soft?: boolean;
}

// ============================================
// Settings genericos para acciones especializadas
// ============================================

export interface GenericActionSettings {
  type: 'generic';
  [key: string]: unknown;          // Cualquier config adicional
}

// Modulos especializados disponibles para registrar
export interface AvailableModule {
  code: string;                    // 'reportes', 'auditoria', etc.
  name: string;                    // 'ReportsModule'
  label: string;                   // 'Modulo de Reportes'
  description: string;             // 'Graficos y exportacion de datos'
  defaultActions: ModuleAction[];  // Acciones por defecto con settings
  defaultIcon: string;             // 'BarChart3'
}

export interface ModuleProps {
  moduleCode: string;
  metadata: ModuleWithPermissions;
}

export type ModuleComponent = React.ComponentType<ModuleProps>;

// Definiciones auxiliares
export interface FieldDefinition {
  name: string;
  label: string;
  type: 'text' | 'number' | 'date' | 'select' | 'textarea' | 'boolean' | 'money';
  required?: boolean;
  options?: Array<{ value: string; label: string }>;
  min?: number;
  max?: number;
  placeholder?: string;
}

export interface ColumnDefinition {
  field: string;
  label: string;
  sortable?: boolean;
  format?: 'date' | 'money' | 'boolean';
}

export interface FilterDefinition {
  field: string;
  label: string;
  type: 'text' | 'select' | 'date' | 'dateRange';
  options?: Array<{ value: string; label: string }>;
}

export interface ValidationRules {
  [field: string]: {
    required?: boolean;
    min?: number;
    max?: number;
    pattern?: string;
    message?: string;
  };
}
```

### 2. ModuleRegistry (apps/web/src/lib/module-registry.ts)

```typescript
import type {
  ModuleWithPermissions,
  ModuleComponent,
  NavItem,
  AvailableModule,
} from './types/modules';

class ModuleRegistry {
  // Modulos especializados disponibles para registrar
  private availableModules = new Map<string, {
    component: ModuleComponent;
    meta: AvailableModule;
  }>();

  // Modulos del usuario actual (cargados de /api/auth/me)
  private userModules: ModuleWithPermissions[] = [];
  private loaded = false;

  /**
   * Registrar modulo especializado (llamado al iniciar app)
   * Esto hace el modulo DISPONIBLE para que el admin lo registre
   */
  registerModule(meta: AvailableModule, component: ModuleComponent): void {
    this.availableModules.set(meta.code, { component, meta });
  }

  /**
   * Obtener lista de modulos disponibles para registrar
   * Usado por el panel de admin para mostrar opciones
   */
  getAvailableModules(): AvailableModule[] {
    return Array.from(this.availableModules.values()).map(v => v.meta);
  }

  /**
   * Verificar si un modulo especializado esta disponible
   */
  hasAvailableModule(code: string): boolean {
    return this.availableModules.has(code);
  }

  /**
   * Cargar modulos del usuario (despues de login, desde /api/auth/me)
   */
  setUserModules(modules: ModuleWithPermissions[]): void {
    this.userModules = modules;
    this.loaded = true;
  }

  /**
   * Limpiar modulos (en logout)
   */
  clear(): void {
    this.userModules = [];
    this.loaded = false;
  }

  /**
   * Verificar si los modulos estan cargados
   */
  isLoaded(): boolean {
    return this.loaded;
  }

  /**
   * Obtener todos los modulos del usuario
   */
  getAllModules(): ModuleWithPermissions[] {
    return this.userModules;
  }

  /**
   * Obtener metadata de un modulo especifico
   */
  getMetadata(code: string): ModuleWithPermissions | undefined {
    return this.userModules.find(m => m.code === code);
  }

  /**
   * Obtener componente para un modulo especializado
   */
  getComponent(code: string): ModuleComponent | null {
    const entry = this.availableModules.get(code);
    return entry?.component || null;
  }

  /**
   * Generar configuracion de navegacion
   */
  getNavConfig(): NavItem[] {
    return this.userModules
      .sort((a, b) => a.nav.order - b.nav.order)
      .map(m => ({
        path: m.nav.path,
        label: m.label,
        icon: m.icon,
        module: m.code,
      }));
  }

  /**
   * Verificar si el usuario tiene acceso a un modulo
   */
  hasModule(code: string): boolean {
    return this.userModules.some(m => m.code === code);
  }

  /**
   * Verificar si tiene una accion especifica en un modulo
   * El codigo de accion coincide con el codigo de permiso
   */
  hasAction(moduleCode: string, actionCode: string): boolean {
    const module = this.getMetadata(moduleCode);
    return module?.actions.some(a => a.code === actionCode) ?? false;
  }

  /**
   * Obtener codigos de accion de un modulo (equivale a permisos)
   */
  getPermissions(moduleCode: string): string[] {
    return this.getMetadata(moduleCode)?.actions.map(a => a.code) ?? [];
  }

  /**
   * Obtener settings de una accion con tipado
   */
  getActionSettings<T extends ActionSettings>(
    moduleCode: string,
    actionCode: string
  ): T | undefined {
    const module = this.getMetadata(moduleCode);
    const action = module?.actions.find(a => a.code === actionCode);
    return action?.settings as T | undefined;
  }

  /**
   * Buscar modulo por path de navegacion
   */
  getModuleByPath(path: string): ModuleWithPermissions | undefined {
    return this.userModules.find(m => m.nav.path === path);
  }
}

// Singleton
export const moduleRegistry = new ModuleRegistry();
```

### 3. Registro de Componentes (apps/web/src/modules/index.ts)

```typescript
import { lazy } from 'react';
import { moduleRegistry } from '@/lib/module-registry';
import type { AvailableModule } from '@/lib/types/modules';

// Componentes con lazy loading
const ReportsModule = lazy(() => import('./reports').then(m => ({ default: m.ReportsModule })));
const AuditModule = lazy(() => import('./audit').then(m => ({ default: m.AuditModule })));
const SettingsModule = lazy(() => import('./settings').then(m => ({ default: m.SettingsModule })));

// Definicion de modulos disponibles con estructura actions unificada
const availableModules: Array<{
  meta: AvailableModule;
  component: React.ComponentType<any>;
}> = [
  {
    meta: {
      code: 'reportes',
      name: 'ReportsModule',
      label: 'Reportes y Estadisticas',
      description: 'Graficos de contribuciones, progreso de objetivos y exportacion de datos',
      defaultIcon: 'BarChart3',
      defaultActions: [
        {
          code: 'view',
          label: 'Ver reportes',
          description: 'Permite visualizar reportes',
          settings: { type: 'generic' }
        },
        {
          code: 'export',
          label: 'Exportar',
          description: 'Permite exportar reportes a PDF/Excel',
          settings: { type: 'generic', formats: ['pdf', 'excel', 'csv'] }
        },
      ],
    },
    component: ReportsModule,
  },
  {
    meta: {
      code: 'auditoria',
      name: 'AuditModule',
      label: 'Auditoria del Sistema',
      description: 'Log de auditoria con filtros avanzados y busqueda',
      defaultIcon: 'FileText',
      defaultActions: [
        {
          code: 'view',
          label: 'Ver logs',
          description: 'Permite ver el log de auditoria',
          settings: { type: 'generic' }
        },
        {
          code: 'search',
          label: 'Buscar',
          description: 'Permite buscar en logs historicos',
          settings: { type: 'generic' }
        },
      ],
    },
    component: AuditModule,
  },
  {
    meta: {
      code: 'configuracion',
      name: 'SettingsModule',
      label: 'Configuracion del Sistema',
      description: 'Configuracion general, notificaciones y opciones avanzadas',
      defaultIcon: 'Settings',
      defaultActions: [
        {
          code: 'view',
          label: 'Ver configuracion',
          description: 'Permite ver la configuracion',
          settings: { type: 'generic' }
        },
        {
          code: 'manage',
          label: 'Administrar',
          description: 'Permite modificar configuracion',
          settings: { type: 'generic' }
        },
      ],
    },
    component: SettingsModule,
  },
];

/**
 * Registrar todos los modulos disponibles
 * Llamar al iniciar la aplicacion
 */
export function registerAvailableModules(): void {
  availableModules.forEach(({ meta, component }) => {
    moduleRegistry.registerModule(meta, component);
  });
}

/**
 * Obtener lista de modulos para el panel de admin
 */
export function getAvailableModulesList(): AvailableModule[] {
  return moduleRegistry.getAvailableModules();
}
```

### 4. React Context (apps/web/src/lib/module-registry.context.tsx)

```typescript
'use client';

import { createContext, useContext, useEffect, useState, type ReactNode } from 'react';
import { moduleRegistry } from './module-registry';
import type { ModuleWithPermissions, NavItem, AvailableModule } from './types/modules';

interface ModuleRegistryContextValue {
  isLoaded: boolean;
  modules: ModuleWithPermissions[];
  navConfig: NavItem[];
  hasModule: (code: string) => boolean;
  hasAction: (moduleCode: string, actionCode: string) => boolean;
  getMetadata: (code: string) => ModuleWithPermissions | undefined;
  getPermissions: (moduleCode: string) => string[];
  getActionSettings: <T extends ActionSettings>(moduleCode: string, actionCode: string) => T | undefined;
  // Para admin
  getAvailableModules: () => AvailableModule[];
}

const ModuleRegistryContext = createContext<ModuleRegistryContextValue | null>(null);

interface Props {
  children: ReactNode;
  initialModules?: ModuleWithPermissions[];
}

export function ModuleRegistryProvider({ children, initialModules }: Props) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [modules, setModules] = useState<ModuleWithPermissions[]>([]);
  const [navConfig, setNavConfig] = useState<NavItem[]>([]);

  useEffect(() => {
    if (initialModules) {
      moduleRegistry.setUserModules(initialModules);
      setModules(initialModules);
      setNavConfig(moduleRegistry.getNavConfig());
      setIsLoaded(true);
    }
  }, [initialModules]);

  const value: ModuleRegistryContextValue = {
    isLoaded,
    modules,
    navConfig,
    hasModule: (code) => moduleRegistry.hasModule(code),
    hasAction: (moduleCode, actionCode) => moduleRegistry.hasAction(moduleCode, actionCode),
    getMetadata: (code) => moduleRegistry.getMetadata(code),
    getPermissions: (moduleCode) => moduleRegistry.getPermissions(moduleCode),
    getActionSettings: (moduleCode, actionCode) => moduleRegistry.getActionSettings(moduleCode, actionCode),
    getAvailableModules: () => moduleRegistry.getAvailableModules(),
  };

  return (
    <ModuleRegistryContext.Provider value={value}>
      {children}
    </ModuleRegistryContext.Provider>
  );
}

export function useModuleRegistry(): ModuleRegistryContextValue {
  const context = useContext(ModuleRegistryContext);
  if (!context) {
    throw new Error('useModuleRegistry must be used within ModuleRegistryProvider');
  }
  return context;
}
```

### 5. Inicializacion en App

```typescript
// apps/web/src/app/layout.tsx
import { registerAvailableModules } from '@/modules';

// Registrar modulos disponibles al iniciar
registerAvailableModules();

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
      </body>
    </html>
  );
}
```

## Panel de Admin - Registro de Modulos

El SuperAdmin puede registrar modulos especializados desde la UI:

```typescript
// apps/web/src/app/(dashboard)/admin/modules/register/page.tsx
'use client';

import { useModuleRegistry } from '@/lib/module-registry.context';
import { useState } from 'react';

export default function RegisterModulePage() {
  const { getAvailableModules } = useModuleRegistry();
  const availableModules = getAvailableModules();

  const [selectedModule, setSelectedModule] = useState('');
  const [formData, setFormData] = useState({
    label: '',
    description: '',
    icon: '',
    path: '',
    order: 0,
  });

  const handleModuleSelect = (code: string) => {
    const module = availableModules.find(m => m.code === code);
    if (module) {
      setSelectedModule(code);
      setFormData({
        label: module.label,
        description: module.description,
        icon: module.defaultIcon,
        path: `/${code}`,
        order: 50,
      });
    }
  };

  const handleSubmit = async () => {
    const module = availableModules.find(m => m.code === selectedModule);
    await fetch('/api/admin/modules', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        code: selectedModule,
        type: 'specialized',
        label: formData.label,
        description: formData.description,
        icon: formData.icon,
        navConfig: {
          path: formData.path,
          order: formData.order,
        },
        specializedConfig: {
          component: module?.name,
          actions: module?.defaultActions,
        },
      }),
    });
  };

  return (
    <div className="space-y-6">
      <h1>Registrar Modulo Especializado</h1>

      <div className="grid gap-4">
        <label>Modulo Disponible</label>
        <select
          value={selectedModule}
          onChange={(e) => handleModuleSelect(e.target.value)}
        >
          <option value="">Seleccione un modulo</option>
          {availableModules.map((m) => (
            <option key={m.code} value={m.code}>
              {m.label} - {m.description}
            </option>
          ))}
        </select>

        {selectedModule && (
          <>
            <input
              placeholder="Etiqueta"
              value={formData.label}
              onChange={(e) => setFormData({ ...formData, label: e.target.value })}
            />
            <input
              placeholder="Descripcion"
              value={formData.description}
              onChange={(e) => setFormData({ ...formData, description: e.target.value })}
            />
            <input
              placeholder="Ruta (ej: /reports)"
              value={formData.path}
              onChange={(e) => setFormData({ ...formData, path: e.target.value })}
            />
            <input
              type="number"
              placeholder="Orden en menu"
              value={formData.order}
              onChange={(e) => setFormData({ ...formData, order: parseInt(e.target.value) })}
            />

            <button onClick={handleSubmit}>Registrar Modulo</button>
          </>
        )}
      </div>
    </div>
  );
}
```

## Ejemplo de Respuesta /api/auth/me

Con modulos especializados registrados (estructura unificada con actions):

```json
{
  "user": { "id": "123", "isSuperAdmin": false },
  "modules": [
    {
      "code": "objetivos",
      "label": "Objetivos",
      "type": "crud",
      "nav": { "path": "/m/objetivos", "order": 10 },
      "entity": "Objetivo",
      "endpoint": "/api/goals",
      "actions": [
        {
          "code": "read",
          "label": "Ver",
          "settings": {
            "type": "read",
            "listColumns": [...]
          }
        },
        {
          "code": "create",
          "label": "Crear",
          "settings": {
            "type": "create",
            "fields": [...]
          }
        }
      ]
    },
    {
      "code": "reportes",
      "label": "Reportes y Estadisticas",
      "type": "specialized",
      "nav": { "path": "/reports", "order": 60 },
      "component": "ReportsModule",
      "actions": [
        {
          "code": "view",
          "label": "Ver reportes",
          "settings": { "type": "generic" }
        },
        {
          "code": "export",
          "label": "Exportar",
          "settings": { "type": "generic", "formats": ["pdf", "excel"] }
        }
      ]
    }
  ]
}
```

## Criterios de Aceptacion

- [ ] ModuleRegistry.registerModule() registra modulos disponibles
- [ ] getAvailableModules() retorna lista para panel admin
- [ ] SuperAdmin puede registrar modulos desde UI
- [ ] Modulos registrados aparecen en /api/auth/me de usuarios con permiso
- [ ] Estructura unificada con `actions` (CRUD y specialized)
- [ ] Acciones CRUD tienen settings tipados (ReadActionSettings, etc.)
- [ ] Acciones especializadas tienen GenericActionSettings
- [ ] hasAction() verifica existencia de accion (codigo = permiso)
- [ ] getActionSettings() obtiene settings tipados
- [ ] Componentes con lazy loading
- [ ] setUserModules recibe datos de /api/auth/me
- [ ] Metodo clear para logout
- [ ] Tests unitarios
