# OB-014-E-003: Crear componente GenericCRUDModule

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-E - Sistema de Permisos Gobernado por Backend |
| Status | done |
| Priority | high |
| Created | 2026-01-06 |
| Updated | 2026-01-06 |
| Labels | task, frontend, components, crud |
| Depends on | OB-014-E-002 |

## Descripcion

Crear un componente generico que renderiza operaciones CRUD basandose en las acciones segregadas del backend. El componente solo muestra las acciones que existen en el array `actions` (porque el usuario tiene el permiso correspondiente - el codigo de accion coincide con el codigo de permiso).

## Estructura de Archivos

```
apps/web/src/components/modules/
├── GenericCRUDModule.tsx       # Componente principal
├── GenericList.tsx             # Lista/tabla generica
├── GenericForm.tsx             # Formulario generico
├── GenericDetail.tsx           # Vista de detalle
├── fields/                     # Campos dinamicos
│   ├── TextField.tsx
│   ├── NumberField.tsx
│   ├── DateField.tsx
│   ├── SelectField.tsx
│   ├── MoneyField.tsx
│   ├── TextareaField.tsx
│   ├── BooleanField.tsx
│   └── index.ts
└── index.ts
```

## Implementacion

### GenericCRUDModule

```typescript
import { useState } from 'react';
import type { ModuleProps, ModuleAction, ReadActionSettings, CreateActionSettings, UpdateActionSettings, DeleteActionSettings } from '@/lib/types/modules';
import { GenericList } from './GenericList';
import { GenericForm } from './GenericForm';
import { GenericDetail } from './GenericDetail';
import { ModuleHeader } from './ModuleHeader';
import { Button } from '@/components/ui/button';

type View = 'list' | 'create' | 'detail' | 'edit';

// Helper para obtener accion por codigo con tipado
function getAction<T>(actions: ModuleAction[], code: string): (ModuleAction & { settings: T }) | undefined {
  return actions.find(a => a.code === code) as (ModuleAction & { settings: T }) | undefined;
}

export function GenericCRUDModule({ moduleCode, metadata }: ModuleProps) {
  const [view, setView] = useState<View>('list');
  const [selectedId, setSelectedId] = useState<string | null>(null);

  // Obtener acciones por codigo - si existe, tiene permiso (codigo accion = codigo permiso)
  const readAction = getAction<ReadActionSettings>(metadata.actions, 'read');
  const createAction = getAction<CreateActionSettings>(metadata.actions, 'create');
  const updateAction = getAction<UpdateActionSettings>(metadata.actions, 'update');
  const deleteAction = getAction<DeleteActionSettings>(metadata.actions, 'delete');

  if (!readAction) {
    return (
      <div className="p-4 text-gray-500">
        No tiene permisos para ver este modulo.
      </div>
    );
  }

  const handleView = (id: string) => {
    setSelectedId(id);
    setView('detail');
  };

  const handleEdit = (id: string) => {
    setSelectedId(id);
    setView('edit');
  };

  const handleDelete = async (id: string) => {
    if (!deleteAction) return;

    const confirmed = window.confirm(deleteAction.settings.confirmation);
    if (!confirmed) return;

    try {
      await fetch(`${metadata.endpoint}/${id}`, { method: 'DELETE' });
      // Refrescar lista
    } catch (error) {
      console.error('Error deleting:', error);
    }
  };

  const handleBack = () => {
    setSelectedId(null);
    setView('list');
  };

  return (
    <div className="space-y-6">
      <ModuleHeader
        title={metadata.label}
        description={metadata.description}
        onBack={view !== 'list' ? handleBack : undefined}
      />

      {view === 'list' && (
        <>
          {createAction && (
            <div className="flex justify-end">
              <Button onClick={() => setView('create')}>
                Crear {metadata.entity}
              </Button>
            </div>
          )}
          <GenericList
            config={readAction.settings}
            endpoint={metadata.endpoint!}
            entity={metadata.entity!}
            onView={handleView}
            onEdit={updateAction ? handleEdit : undefined}
            onDelete={deleteAction ? handleDelete : undefined}
          />
        </>
      )}

      {view === 'create' && createAction && (
        <GenericForm
          config={createAction.settings}
          endpoint={metadata.endpoint!}
          entity={metadata.entity!}
          mode="create"
          onSuccess={handleBack}
          onCancel={handleBack}
        />
      )}

      {view === 'detail' && selectedId && (
        <GenericDetail
          config={readAction.settings}
          endpoint={metadata.endpoint!}
          entity={metadata.entity!}
          id={selectedId}
          onEdit={updateAction ? () => setView('edit') : undefined}
          onBack={handleBack}
        />
      )}

      {view === 'edit' && selectedId && updateAction && (
        <GenericForm
          config={updateAction.settings}
          endpoint={`${metadata.endpoint}/${selectedId}`}
          entity={metadata.entity!}
          mode="edit"
          id={selectedId}
          onSuccess={handleBack}
          onCancel={handleBack}
        />
      )}
    </div>
  );
}
```

### GenericList

```typescript
import { useEffect, useState } from 'react';
import type { ReadActionSettings } from '@/lib/types/modules';
import {
  Table,
  TableHeader,
  TableBody,
  TableRow,
  TableHead,
  TableCell,
} from '@/components/ui/table';
import { Button } from '@/components/ui/button';
import { formatValue } from '@/lib/formatters';

interface Props {
  config: ReadActionSettings;  // Settings tipados del action 'read'
  endpoint: string;
  entity: string;
  onView: (id: string) => void;
  onEdit?: (id: string) => void;
  onDelete?: (id: string) => void;
}

export function GenericList({ config, endpoint, entity, onView, onEdit, onDelete }: Props) {
  const [data, setData] = useState<Record<string, unknown>[]>([]);
  const [loading, setLoading] = useState(true);
  const [sortField, setSortField] = useState<string | null>(null);
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

  useEffect(() => {
    fetchData();
  }, [endpoint, sortField, sortOrder]);

  const fetchData = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (sortField) {
        params.set('sortBy', sortField);
        params.set('sortOrder', sortOrder);
      }
      const response = await fetch(`${endpoint}?${params}`);
      const result = await response.json();
      setData(result.data || result);
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSort = (field: string) => {
    if (!config.sortable?.includes(field)) return;
    if (sortField === field) {
      setSortOrder(prev => prev === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortOrder('asc');
    }
  };

  if (loading) {
    return <div className="animate-pulse">Cargando...</div>;
  }

  return (
    <div className="border rounded-lg">
      <Table>
        <TableHeader>
          <TableRow>
            {config.listColumns.map(col => (
              <TableHead
                key={col.field}
                className={col.sortable ? 'cursor-pointer hover:bg-gray-50' : ''}
                onClick={() => col.sortable && handleSort(col.field)}
              >
                {col.label}
                {sortField === col.field && (sortOrder === 'asc' ? ' ↑' : ' ↓')}
              </TableHead>
            ))}
            <TableHead>Acciones</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((row) => (
            <TableRow key={row.id as string}>
              {config.listColumns.map(col => (
                <TableCell key={col.field}>
                  {formatValue(row[col.field], col.format)}
                </TableCell>
              ))}
              <TableCell>
                <div className="flex gap-2">
                  <Button variant="ghost" size="sm" onClick={() => onView(row.id as string)}>
                    Ver
                  </Button>
                  {onEdit && (
                    <Button variant="ghost" size="sm" onClick={() => onEdit(row.id as string)}>
                      Editar
                    </Button>
                  )}
                  {onDelete && (
                    <Button
                      variant="ghost"
                      size="sm"
                      className="text-red-500"
                      onClick={() => onDelete(row.id as string)}
                    >
                      Eliminar
                    </Button>
                  )}
                </div>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>

      {data.length === 0 && (
        <div className="p-8 text-center text-gray-500">
          No hay {entity.toLowerCase()}s registrados.
        </div>
      )}
    </div>
  );
}
```

### GenericForm

```typescript
import { useForm } from 'react-hook-form';
import { useEffect, useState } from 'react';
import type { CreateActionSettings, UpdateActionSettings } from '@/lib/types/modules';
import { DynamicField } from './fields';
import { Button } from '@/components/ui/button';

interface Props {
  config: CreateActionSettings | UpdateActionSettings;  // Settings tipados
  endpoint: string;
  entity: string;
  mode: 'create' | 'edit';
  id?: string;
  onSuccess: () => void;
  onCancel: () => void;
}

export function GenericForm({ config, endpoint, entity, mode, id, onSuccess, onCancel }: Props) {
  const [loading, setLoading] = useState(false);
  const { register, handleSubmit, reset, formState: { errors } } = useForm();

  // Cargar datos existentes en modo edit
  useEffect(() => {
    if (mode === 'edit' && id) {
      fetch(endpoint)
        .then(res => res.json())
        .then(data => reset(data));
    }
  }, [mode, id, endpoint, reset]);

  const onSubmit = async (data: Record<string, unknown>) => {
    setLoading(true);
    try {
      const method = mode === 'create' ? 'POST' : 'PUT';
      const url = mode === 'create' ? endpoint : endpoint;

      await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      onSuccess();
    } catch (error) {
      console.error('Error saving:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <h2 className="text-xl font-semibold">
        {mode === 'create' ? `Crear ${entity}` : `Editar ${entity}`}
      </h2>

      <div className="grid gap-4 md:grid-cols-2">
        {config.fields.map(field => (
          <DynamicField
            key={field.name}
            field={field}
            register={register}
            error={errors[field.name]?.message as string}
          />
        ))}
      </div>

      <div className="flex gap-4 justify-end">
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancelar
        </Button>
        <Button type="submit" disabled={loading}>
          {loading ? 'Guardando...' : 'Guardar'}
        </Button>
      </div>
    </form>
  );
}
```

### Campos Dinamicos (fields/index.ts)

```typescript
import type { FieldDefinition } from '@/lib/types/modules';
import type { UseFormRegister } from 'react-hook-form';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';

interface Props {
  field: FieldDefinition;
  register: UseFormRegister<Record<string, unknown>>;
  error?: string;
}

export function DynamicField({ field, register, error }: Props) {
  const baseProps = {
    ...register(field.name, { required: field.required }),
    placeholder: field.placeholder,
  };

  const renderInput = () => {
    switch (field.type) {
      case 'text':
        return <Input type="text" {...baseProps} />;

      case 'number':
        return <Input type="number" min={field.min} max={field.max} {...baseProps} />;

      case 'money':
        return (
          <div className="relative">
            <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500">$</span>
            <Input type="number" step="0.01" className="pl-7" {...baseProps} />
          </div>
        );

      case 'date':
        return <Input type="date" {...baseProps} />;

      case 'textarea':
        return <Textarea {...baseProps} />;

      case 'boolean':
        return (
          <div className="flex items-center gap-2">
            <Checkbox {...register(field.name)} />
            <span>{field.label}</span>
          </div>
        );

      case 'select':
        return (
          <Select {...register(field.name)}>
            <SelectTrigger>
              <SelectValue placeholder={`Seleccione ${field.label.toLowerCase()}`} />
            </SelectTrigger>
            <SelectContent>
              {field.options?.map(opt => (
                <SelectItem key={opt.value} value={opt.value}>
                  {opt.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      default:
        return <Input type="text" {...baseProps} />;
    }
  };

  if (field.type === 'boolean') {
    return (
      <div className="col-span-full">
        {renderInput()}
        {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
      </div>
    );
  }

  return (
    <div>
      <Label htmlFor={field.name}>
        {field.label}
        {field.required && <span className="text-red-500 ml-1">*</span>}
      </Label>
      {renderInput()}
      {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
    </div>
  );
}
```

## Criterios de Aceptacion

- [ ] GenericCRUDModule renderiza lista, detalle, crear, editar segun acciones disponibles
- [ ] Solo muestra acciones que existen en el array `actions` (codigo accion = codigo permiso)
- [ ] Usa tipos tipados: ReadActionSettings, CreateActionSettings, UpdateActionSettings, DeleteActionSettings
- [ ] Campos se generan dinamicamente desde settings.fields
- [ ] Soporta todos los tipos de campo (text, number, money, date, select, textarea, boolean)
- [ ] Integracion con react-hook-form
- [ ] Manejo de errores y loading states
- [ ] Confirmacion de eliminacion usando deleteAction.settings.confirmation
- [ ] Tests de componentes
