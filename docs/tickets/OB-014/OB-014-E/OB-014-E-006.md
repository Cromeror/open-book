# OB-014-E-006: Eliminar tipos hardcodeados del frontend

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-E - Sistema de Permisos Gobernado por Backend |
| Status | pending |
| Priority | high |
| Created | 2026-01-06 |
| Updated | 2026-01-06 |
| Labels | task, frontend, cleanup, types |
| Depends on | OB-014-E-001, OB-014-E-002 |

## Descripcion

Eliminar todos los tipos hardcodeados de permisos del frontend. El frontend usara strings genericos y validara en runtime contra los datos recibidos de `/api/auth/me`.

## Archivos a Modificar

### 1. apps/web/src/lib/types.ts

**ANTES:**
```typescript
export type ModuleCode =
  | 'users'
  | 'copropiedades'
  | 'objetivos'
  // ... union types hardcodeados

export type PermissionAction =
  | 'create'
  | 'read'
  // ... union types hardcodeados
```

**DESPUES:**
```typescript
// Solo interfaces para respuestas del API - strings genericos

export interface AuthMeResponse {
  user: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    isSuperAdmin: boolean;
  };
  modules: ModuleWithPermissions[];
}

// Validacion en runtime
// El codigo de accion ES el codigo de permiso
export function hasAction(
  modules: ModuleWithPermissions[],
  moduleCode: string,
  actionCode: string
): boolean {
  const module = modules.find(m => m.code === moduleCode);
  return module?.actions.some(a => a.code === actionCode) ?? false;
}

export function hasModule(
  modules: ModuleWithPermissions[],
  moduleCode: string
): boolean {
  return modules.some(m => m.code === moduleCode);
}

// Helper para obtener settings tipados
export function getActionSettings<T extends ActionSettings>(
  modules: ModuleWithPermissions[],
  moduleCode: string,
  actionCode: string
): T | undefined {
  const module = modules.find(m => m.code === moduleCode);
  const action = module?.actions.find(a => a.code === actionCode);
  return action?.settings as T | undefined;
}
```

### 2. apps/web/src/lib/nav-config.ts

**Eliminar archivo completamente.** La navegacion se genera desde los modulos del usuario via `moduleRegistry.getNavConfig()`.

### 3. apps/web/src/lib/permissions.server.ts

Modificar para usar strings genericos y `hasAction`:

```typescript
import { getServerSession } from '@/lib/auth';

// Cache de modulos del usuario en el request
let cachedModules: ModuleWithActions[] | null = null;

async function getServerModules(): Promise<ModuleWithActions[]> {
  if (cachedModules) return cachedModules;

  const session = await getServerSession();
  if (!session) throw new Error('Unauthorized');

  // Fetch desde API o cache
  const response = await fetch(`${API_URL}/api/auth/me`, {
    headers: { Authorization: `Bearer ${session.token}` },
  });
  const data = await response.json();
  cachedModules = data.modules;
  return cachedModules;
}

export async function requireModule(moduleCode: string): Promise<void> {
  const modules = await getServerModules();
  const hasModule = modules.some(m => m.code === moduleCode);
  if (!hasModule) {
    throw new Error('Access denied');
  }
}

// codigo de accion = codigo de permiso
export async function requireAction(moduleCode: string, actionCode: string): Promise<void> {
  const modules = await getServerModules();
  const module = modules.find(m => m.code === moduleCode);
  const hasAction = module?.actions.some(a => a.code === actionCode) ?? false;
  if (!hasAction) {
    throw new Error('Access denied');
  }
}

// Helper para obtener settings de una accion
export async function getActionSettings<T extends ActionSettings>(
  moduleCode: string,
  actionCode: string
): Promise<T | undefined> {
  const modules = await getServerModules();
  const module = modules.find(m => m.code === moduleCode);
  const action = module?.actions.find(a => a.code === actionCode);
  return action?.settings as T | undefined;
}
```

### 4. Componentes que usan tipos

Actualizar todos los componentes que importan `ModuleCode` o `PermissionAction`:

#### ShowForModule.tsx
```typescript
// ANTES
interface Props {
  module: ModuleCode;
  children: React.ReactNode;
}

// DESPUES
interface Props {
  module: string;  // string generico
  children: React.ReactNode;
}

export function ShowForModule({ module, children }: Props) {
  const { hasModule } = useModuleRegistry();

  if (!hasModule(module)) {
    return null;
  }

  return <>{children}</>;
}
```

#### ShowForAction.tsx
```typescript
// ANTES
interface Props {
  permission: `${ModuleCode}:${PermissionAction}`;
  children: React.ReactNode;
}

// DESPUES - Renombrado a ShowForAction (codigo accion = codigo permiso)
interface Props {
  module: string;
  action: string;  // codigo de accion = codigo de permiso
  children: React.ReactNode;
}

export function ShowForAction({ module, action, children }: Props) {
  const { hasAction } = useModuleRegistry();

  if (!hasAction(module, action)) {
    return null;
  }

  return <>{children}</>;
}
```

#### module-registry.context.tsx (reemplaza permissions.context.tsx)
```typescript
// ANTES (permissions.context.tsx)
interface PermissionsContextValue {
  modules: ModuleCode[];
  permissions: Permission[];
  hasModule: (module: ModuleCode) => boolean;
  hasPermission: (module: ModuleCode, action: PermissionAction) => boolean;
}

// DESPUES (module-registry.context.tsx)
// Usa ModuleRegistry como fuente de verdad
interface ModuleRegistryContextValue {
  isLoaded: boolean;
  modules: ModuleWithActions[];  // Modulos con sus acciones
  hasModule: (moduleCode: string) => boolean;
  hasAction: (moduleCode: string, actionCode: string) => boolean;  // codigo accion = codigo permiso
  getActionSettings: <T extends ActionSettings>(moduleCode: string, actionCode: string) => T | undefined;
  getMetadata: (moduleCode: string) => ModuleWithActions | undefined;
  navConfig: NavItem[];
  isSuperAdmin: boolean;
}
```

## Buscar y Reemplazar

Ejecutar busqueda en todo el proyecto:

```bash
# Encontrar imports de tipos hardcodeados
grep -r "ModuleCode" apps/web/src/
grep -r "PermissionAction" apps/web/src/
grep -r "PermissionScope" apps/web/src/

# Encontrar usos de union types
grep -r "type.*=.*\|.*\|" apps/web/src/lib/types.ts

# Encontrar usos antiguos de hasPermission (debe ser hasAction)
grep -r "hasPermission" apps/web/src/

# Encontrar referencias a permissions.context (debe ser module-registry.context)
grep -r "permissions.context" apps/web/src/

# Encontrar ShowForPermission (debe ser ShowForAction)
grep -r "ShowForPermission" apps/web/src/
```

## Beneficios

1. **Sin sincronizacion** - No hay tipos que mantener en sync con backend
2. **Flexibilidad** - Agregar modulo en backend no requiere cambios en frontend
3. **Runtime validation** - Errores se detectan pero no bloquean compilacion
4. **Backend como fuente de verdad** - Un solo lugar para la configuracion
5. **Menos codigo** - Elimina duplicacion de definiciones

## Riesgos y Mitigaciones

| Riesgo | Mitigacion |
|--------|------------|
| Errores de typo en strings | Usar constantes para strings comunes |
| Perdida de autocompletado | Los editores sugieren strings usados |
| Errores silenciosos | Tests de integracion validan flujo |

## Criterios de Aceptacion

- [ ] types.ts solo tiene interfaces con strings genericos
- [ ] nav-config.ts eliminado
- [ ] permissions.server.ts usa strings y hasAction
- [ ] permissions.context.tsx renombrado a module-registry.context.tsx
- [ ] ShowForPermission.tsx renombrado a ShowForAction.tsx
- [ ] Todos los componentes usan hasAction en lugar de hasPermission
- [ ] No hay imports de ModuleCode, PermissionAction, PermissionScope
- [ ] Build pasa sin errores de tipos
- [ ] Tests actualizados para usar actions
- [ ] No hay union types hardcodeados de permisos en frontend
- [ ] Codigo de accion = codigo de permiso (verificacion en runtime)
