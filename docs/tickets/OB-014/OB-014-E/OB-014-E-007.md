# OB-014-E-007: Tests de integracion

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Permisos y Modulos |
| Story | OB-014-E - Sistema de Permisos Gobernado por Backend |
| Status | pending |
| Priority | medium |
| Created | 2026-01-06 |
| Updated | 2026-01-06 |
| Labels | task, testing, integration |
| Depends on | OB-014-E-001 a OB-014-E-006 |

## Descripcion

Crear tests de integracion que validen el flujo completo del sistema de permisos gobernado por backend.

## Tests a Implementar

### 1. Backend - /api/auth/me con Modulos

```typescript
// apps/api-e2e/src/auth-me-modules.spec.ts
describe('GET /api/auth/me - Modules & Permissions', () => {
  it('should return user with modules and permissions', async () => {
    const { token } = await loginAsUser('regular@test.com');

    const response = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${token}`);

    expect(response.status).toBe(200);
    expect(response.body.user).toBeDefined();
    expect(response.body.modules).toBeInstanceOf(Array);
    expect(response.body.modules.length).toBeGreaterThan(0);
  });

  it('should include module metadata with actions', async () => {
    const { token } = await loginAsUser('admin@test.com');

    const response = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${token}`);

    const module = response.body.modules[0];
    expect(module.code).toBeDefined();
    expect(module.label).toBeDefined();
    expect(module.type).toMatch(/^(crud|specialized)$/);
    // Usa actions en lugar de permissions
    expect(module.actions).toBeInstanceOf(Array);
    expect(module.actions.length).toBeGreaterThan(0);
    // Cada accion tiene code, label, settings
    const action = module.actions[0];
    expect(action.code).toBeDefined();
    expect(action.label).toBeDefined();
    expect(action.settings).toBeDefined();
    expect(module.nav).toBeDefined();
    expect(module.nav.path).toBeDefined();
    expect(typeof module.nav.order).toBe('number');
  });

  it('should segregate actions by permission (codigo accion = codigo permiso)', async () => {
    // Usuario con solo READ - solo recibe action 'read'
    const { token } = await loginAsUser('readonly@test.com');

    const response = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${token}`);

    const crudModule = response.body.modules.find(m => m.type === 'crud');
    // Solo tiene la accion 'read' porque solo tiene ese permiso
    const actionCodes = crudModule.actions.map(a => a.code);
    expect(actionCodes).toContain('read');
    expect(actionCodes).not.toContain('create');
    expect(actionCodes).not.toContain('update');
    expect(actionCodes).not.toContain('delete');
    // La accion read tiene sus settings tipados
    const readAction = crudModule.actions.find(a => a.code === 'read');
    expect(readAction.settings.type).toBe('read');
    expect(readAction.settings.listColumns).toBeDefined();
  });

  it('should include actions for all permissions user has', async () => {
    // Usuario con READ, CREATE, UPDATE - recibe esas 3 acciones
    const { token } = await loginAsUser('editor@test.com');

    const response = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${token}`);

    const crudModule = response.body.modules.find(m => m.type === 'crud');
    const actionCodes = crudModule.actions.map(a => a.code);
    expect(actionCodes).toContain('read');
    expect(actionCodes).toContain('create');
    expect(actionCodes).toContain('update');
    // Cada accion tiene settings con su tipo
    expect(crudModule.actions.find(a => a.code === 'read').settings.type).toBe('read');
    expect(crudModule.actions.find(a => a.code === 'create').settings.type).toBe('create');
    expect(crudModule.actions.find(a => a.code === 'update').settings.type).toBe('update');
  });

  it('SuperAdmin should have all modules with all actions', async () => {
    const { token } = await loginAsSuperAdmin();

    const response = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${token}`);

    // Verificar que tiene mas modulos que usuario normal
    expect(response.body.modules.length).toBeGreaterThan(5);
    expect(response.body.user.isSuperAdmin).toBe(true);

    // Verificar que modulos CRUD tienen todas las acciones
    const crudModule = response.body.modules.find(m => m.type === 'crud');
    const actionCodes = crudModule.actions.map(a => a.code);
    expect(actionCodes).toContain('read');
    expect(actionCodes).toContain('create');
    expect(actionCodes).toContain('update');
    expect(actionCodes).toContain('delete');
  });

  it('should include actions with generic settings for specialized modules', async () => {
    const { token } = await loginAsUser('admin@test.com');

    const response = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${token}`);

    const specializedModule = response.body.modules.find(m => m.type === 'specialized');
    if (specializedModule) {
      expect(specializedModule.component).toBeDefined();
      expect(specializedModule.actions).toBeInstanceOf(Array);
      // Modulos especializados tienen acciones con settings genericos
      const action = specializedModule.actions[0];
      expect(action.code).toBeDefined();
      expect(action.settings.type).toBe('generic');
    }
  });
});
```

### 2. Frontend - ModuleRegistry

```typescript
// apps/web/src/lib/__tests__/module-registry.spec.ts
describe('ModuleRegistry', () => {
  beforeEach(() => {
    moduleRegistry.clear();
  });

  // Helper para crear modulo con acciones
  const createModule = (code: string, actions: Array<{ code: string; settings: { type: string } }>, nav: { path: string; order: number }) => ({
    code,
    label: code,
    icon: 'FileText',
    type: 'crud' as const,
    actions,
    nav,
  });

  it('should set user modules with actions', () => {
    const modules = [
      createModule('test', [{ code: 'read', settings: { type: 'read' } }], { path: '/test', order: 1 })
    ];

    moduleRegistry.setUserModules(modules);

    expect(moduleRegistry.isLoaded()).toBe(true);
    expect(moduleRegistry.getAllModules()).toEqual(modules);
  });

  it('should check module access', () => {
    moduleRegistry.setUserModules([
      createModule('objetivos', [{ code: 'read', settings: { type: 'read' } }], { path: '/goals', order: 1 })
    ]);

    expect(moduleRegistry.hasModule('objetivos')).toBe(true);
    expect(moduleRegistry.hasModule('aportes')).toBe(false);
  });

  it('should check actions (codigo accion = codigo permiso)', () => {
    moduleRegistry.setUserModules([
      createModule('objetivos', [
        { code: 'read', settings: { type: 'read' } },
        { code: 'create', settings: { type: 'create' } }
      ], { path: '/goals', order: 1 })
    ]);

    // hasAction verifica si el usuario tiene el permiso via codigo de accion
    expect(moduleRegistry.hasAction('objetivos', 'read')).toBe(true);
    expect(moduleRegistry.hasAction('objetivos', 'create')).toBe(true);
    expect(moduleRegistry.hasAction('objetivos', 'delete')).toBe(false);
  });

  it('should get action settings typed', () => {
    const readSettings = { type: 'read', listColumns: [{ field: 'name', label: 'Nombre' }] };
    moduleRegistry.setUserModules([
      createModule('objetivos', [{ code: 'read', settings: readSettings }], { path: '/goals', order: 1 })
    ]);

    const settings = moduleRegistry.getActionSettings<ReadActionSettings>('objetivos', 'read');
    expect(settings?.type).toBe('read');
    expect(settings?.listColumns).toBeDefined();
  });

  it('should generate nav config sorted by order', () => {
    moduleRegistry.setUserModules([
      createModule('b', [{ code: 'read', settings: { type: 'read' } }], { path: '/b', order: 20 }),
      createModule('a', [{ code: 'read', settings: { type: 'read' } }], { path: '/a', order: 10 }),
    ]);

    const navConfig = moduleRegistry.getNavConfig();

    expect(navConfig[0].module).toBe('a');
    expect(navConfig[1].module).toBe('b');
  });

  it('should return specialized component', () => {
    const MockComponent = () => null;
    moduleRegistry.register('reportes', MockComponent);
    moduleRegistry.setUserModules([{
      code: 'reportes',
      label: 'Reportes',
      icon: 'BarChart3',
      type: 'specialized',
      component: 'ReportsModule',
      actions: [{ code: 'view', settings: { type: 'generic' } }],
      nav: { path: '/reports', order: 1 }
    }]);

    const component = moduleRegistry.getSpecializedComponent('reportes');
    expect(component).toBe(MockComponent);
  });

  it('should return null for CRUD modules', () => {
    moduleRegistry.setUserModules([
      createModule('objetivos', [{ code: 'read', settings: { type: 'read' } }], { path: '/goals', order: 1 })
    ]);

    const component = moduleRegistry.getSpecializedComponent('objetivos');
    expect(component).toBeNull();
  });

  it('should clear modules on logout', () => {
    moduleRegistry.setUserModules([
      createModule('test', [{ code: 'read', settings: { type: 'read' } }], { path: '/test', order: 1 })
    ]);

    moduleRegistry.clear();

    expect(moduleRegistry.isLoaded()).toBe(false);
    expect(moduleRegistry.getAllModules()).toEqual([]);
  });
});
```

### 3. Frontend - GenericCRUDModule

```typescript
// apps/web/src/components/modules/__tests__/GenericCRUDModule.spec.tsx
describe('GenericCRUDModule', () => {
  // Metadata usa actions array en lugar de crud object
  const mockMetadata = {
    code: 'test',
    label: 'Test Module',
    description: 'Test description',
    icon: 'FileText',
    type: 'crud' as const,
    entity: 'Test',
    endpoint: '/api/test',
    actions: [
      {
        code: 'read',
        label: 'Ver',
        settings: {
          type: 'read',
          listColumns: [{ field: 'name', label: 'Name', sortable: true }],
        }
      },
      {
        code: 'create',
        label: 'Crear',
        settings: {
          type: 'create',
          fields: [{ name: 'name', label: 'Name', type: 'text', required: true }],
        }
      }
    ],
    nav: { path: '/test', order: 1 },
  };

  it('should show create button when has create action', () => {
    render(<GenericCRUDModule
      moduleCode="test"
      metadata={mockMetadata}
    />);

    expect(screen.getByText('Crear Test')).toBeInTheDocument();
  });

  it('should hide create button without create action', () => {
    const metadataWithoutCreate = {
      ...mockMetadata,
      // Solo tiene action 'read'
      actions: [mockMetadata.actions[0]],
    };

    render(<GenericCRUDModule
      moduleCode="test"
      metadata={metadataWithoutCreate}
    />);

    expect(screen.queryByText('Crear Test')).not.toBeInTheDocument();
  });

  it('should render list with columns from read action settings', async () => {
    fetchMock.mockResponseOnce(JSON.stringify([{ id: '1', name: 'Test Item' }]));

    render(<GenericCRUDModule
      moduleCode="test"
      metadata={mockMetadata}
    />);

    await waitFor(() => {
      expect(screen.getByText('Test Item')).toBeInTheDocument();
    });
  });

  it('should show edit/delete buttons based on actions', async () => {
    const metadataWithAll = {
      ...mockMetadata,
      actions: [
        ...mockMetadata.actions,
        {
          code: 'update',
          label: 'Editar',
          settings: { type: 'update', fields: [] }
        },
        {
          code: 'delete',
          label: 'Eliminar',
          settings: { type: 'delete', confirmation: 'Delete?' }
        }
      ],
    };

    fetchMock.mockResponseOnce(JSON.stringify([{ id: '1', name: 'Test Item' }]));

    render(<GenericCRUDModule
      moduleCode="test"
      metadata={metadataWithAll}
    />);

    await waitFor(() => {
      expect(screen.getByText('Editar')).toBeInTheDocument();
      expect(screen.getByText('Eliminar')).toBeInTheDocument();
    });
  });

  it('should use action settings for form fields', async () => {
    render(<GenericCRUDModule
      moduleCode="test"
      metadata={mockMetadata}
    />);

    // Click crear
    fireEvent.click(screen.getByText('Crear Test'));

    // Verifica que el formulario usa los fields de createAction.settings.fields
    await waitFor(() => {
      expect(screen.getByLabelText('Name')).toBeInTheDocument();
    });
  });
});
```

### 4. E2E - Flujo Completo

```typescript
// apps/web-e2e/src/permissions-flow.spec.ts
describe('Permissions Flow - Actions based', () => {
  it('should show only modules user has access to in navigation', async () => {
    await loginAsUser('limited@test.com'); // User con solo 'objetivos'

    await expect(page.locator('[data-nav="objetivos"]')).toBeVisible();
    await expect(page.locator('[data-nav="aportes"]')).not.toBeVisible();
  });

  it('should render CRUD module with actions from metadata', async () => {
    await loginAsUser('admin@test.com');
    await page.goto('/m/objetivos');

    await expect(page.locator('h1')).toContainText('Objetivos');
    await expect(page.locator('table')).toBeVisible();
  });

  it('should show create button only when has create action (codigo accion = codigo permiso)', async () => {
    // Usuario con solo action 'read' - no tiene permiso 'create'
    await loginAsUser('readonly@test.com');
    await page.goto('/m/objetivos');

    await expect(page.getByRole('button', { name: /crear/i })).not.toBeVisible();

    // Usuario con action 'create' - tiene permiso 'create'
    await loginAsUser('editor@test.com');
    await page.goto('/m/objetivos');

    await expect(page.getByRole('button', { name: /crear/i })).toBeVisible();
  });

  it('should render specialized module with action-based controls', async () => {
    await loginAsUser('admin@test.com');
    await page.goto('/reports');

    await expect(page.locator('[data-testid="reports-chart"]')).toBeVisible();
    // Si tiene action 'export', debe mostrar boton exportar
    await expect(page.getByRole('button', { name: /exportar/i })).toBeVisible();
  });

  it('SuperAdmin should access all modules with all actions', async () => {
    await loginAsSuperAdmin();

    // Verificar que todos los modulos estan en navegacion
    await expect(page.locator('[data-nav="objetivos"]')).toBeVisible();
    await expect(page.locator('[data-nav="aportes"]')).toBeVisible();
    await expect(page.locator('[data-nav="admin"]')).toBeVisible();

    // Verificar que tiene todas las acciones (crear, editar, eliminar)
    await page.goto('/m/objetivos');
    await expect(page.getByRole('button', { name: /crear/i })).toBeVisible();
  });

  it('should redirect unauthorized access to module', async () => {
    await loginAsUser('limited@test.com');
    await page.goto('/m/aportes'); // No tiene este modulo

    await expect(page).toHaveURL('/dashboard');
  });

  it('should hide action buttons without corresponding action', async () => {
    // Usuario con read y create pero sin update ni delete
    await loginAsUser('creator@test.com');
    await page.goto('/m/objetivos');

    // Puede ver y crear
    await expect(page.getByRole('button', { name: /crear/i })).toBeVisible();

    // En la tabla, no debe tener botones editar/eliminar
    await expect(page.getByRole('button', { name: /editar/i })).not.toBeVisible();
    await expect(page.getByRole('button', { name: /eliminar/i })).not.toBeVisible();
  });
});
```

## Criterios de Aceptacion

- [ ] Tests de /api/auth/me con modulos y actions segregadas
- [ ] Tests unitarios de ModuleRegistry con hasAction y getActionSettings
- [ ] Tests de GenericCRUDModule usando actions array
- [ ] Tests E2E del flujo completo con actions
- [ ] Test de segregacion de actions por permiso (codigo accion = codigo permiso)
- [ ] Test de SuperAdmin con todos los modulos y todas las actions
- [ ] Test de settings tipados (ReadActionSettings, CreateActionSettings, etc.)
- [ ] Test de modulos especializados con GenericActionSettings
- [ ] Cobertura > 80% para codigo nuevo
- [ ] CI pasa todos los tests
