# OB-014-D-003: Crear utilidades de permisos granulares (frontend)

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-014 - Configuracion de Vistas por Rol de Usuario |
| Story | OB-014-D - Componentes compartidos y utilidades de rol |
| Status | pending |
| Priority | high |
| Created | 2026-01-05 |
| Updated | 2026-01-05 |
| Labels | task, frontend, utilities, permissions, granular |
| Depends on | OB-002-C-001 |
| Assigned | unassigned |

## Descripcion

Crear modulo de utilidades para manejo de permisos granulares en el frontend, sincronizado con el sistema de permisos del backend (OB-002-C). Incluye permisos por recurso:accion:scope.

## Contexto Tecnico

### Archivos afectados
- `apps/web/src/lib/permissions.ts`
- `apps/web/src/lib/routes.ts`
- `apps/web/src/hooks/usePermissions.ts`
- `apps/web/src/types/permissions.ts`

### Enfoque tecnico
Definir permisos de forma centralizada, sincronizados con el backend. El frontend recibe permisos efectivos del usuario desde el JWT o endpoint /me.

## Criterios de Aceptacion

- [ ] Enums de Resource, Action, Scope sincronizados con backend
- [ ] Hook usePermissions para verificar permisos con contexto
- [ ] Funciones para verificar permisos granulares
- [ ] Soporte para permisos delegados (recibidos del backend)
- [ ] Rutas por rol definidas
- [ ] Sincronizado con permisos del backend (OB-002-C)

## Notas de Implementacion

```typescript
// types/permissions.ts
export enum Resource {
  USERS = 'users',
  COPROPIEDADES = 'copropiedades',
  APARTAMENTOS = 'apartamentos',
  OBJETIVOS = 'objetivos',
  ACTIVIDADES = 'actividades',
  COMPROMISOS = 'compromisos',
  APORTES = 'aportes',
  PQR = 'pqr',
  REPORTES = 'reportes',
  AUDITORIA = 'auditoria',
  NOTIFICACIONES = 'notificaciones',
  CONFIGURACION = 'configuracion',
}

export enum Action {
  CREATE = 'create',
  READ = 'read',
  UPDATE = 'update',
  DELETE = 'delete',
  EXPORT = 'export',
  MANAGE = 'manage',
}

export enum Scope {
  OWN = 'own',
  COPROPIEDAD = 'copropiedad',
  ALL = 'all',
}

export type Permission = `${Resource}:${Action}` | `${Resource}:${Action}:${Scope}`;

// lib/permissions.ts
import { Role } from '@/types/auth';
import { Permission, Resource, Action, Scope } from '@/types/permissions';

// Permisos base por rol (mismos que backend)
export const ROLE_PERMISSIONS: Record<Role, Permission[]> = {
  [Role.ADMIN]: [
    'users:read:copropiedad',
    'users:create:copropiedad',
    'users:update:copropiedad',
    'copropiedades:read:copropiedad',
    'copropiedades:update:copropiedad',
    'apartamentos:read:copropiedad',
    'apartamentos:create:copropiedad',
    'apartamentos:update:copropiedad',
    'apartamentos:delete:copropiedad',
    'objetivos:read:copropiedad',
    'objetivos:create:copropiedad',
    'objetivos:update:copropiedad',
    'objetivos:delete:copropiedad',
    'actividades:read:copropiedad',
    'actividades:create:copropiedad',
    'actividades:update:copropiedad',
    'actividades:delete:copropiedad',
    'compromisos:read:copropiedad',
    'compromisos:create:copropiedad',
    'compromisos:update:copropiedad',
    'aportes:read:copropiedad',
    'aportes:create:copropiedad',
    'aportes:update:copropiedad',
    'pqr:read:copropiedad',
    'pqr:manage:copropiedad',
    'reportes:read:copropiedad',
    'reportes:export:copropiedad',
    'auditoria:read:copropiedad',
    'notificaciones:read:copropiedad',
    'notificaciones:create:copropiedad',
    'configuracion:read:copropiedad',
    'configuracion:update:copropiedad',
  ],
  [Role.RESIDENT]: [
    'copropiedades:read:own',
    'apartamentos:read:own',
    'objetivos:read:copropiedad',
    'actividades:read:copropiedad',
    'compromisos:read:own',
    'aportes:read:own',
    'pqr:read:own',
    'pqr:create:own',
    'users:read:own',
    'users:update:own',
    'notificaciones:read:own',
  ],
};

// hooks/usePermissions.ts
import { useAuth } from './useAuth';
import { Permission, Resource, Action, Scope } from '@/types/permissions';
import { ROLE_PERMISSIONS } from '@/lib/permissions';

interface PermissionContext {
  copropiedadId?: string;
  resourceOwnerId?: string;
}

export function usePermissions() {
  const { user } = useAuth();

  /**
   * Verifica si el usuario tiene un permiso especifico
   */
  const hasPermission = (
    permission: Permission,
    context?: PermissionContext
  ): boolean => {
    if (!user) return false;

    // Obtener permisos base del rol
    const rolePermissions = ROLE_PERMISSIONS[user.role] || [];

    // Agregar permisos delegados (si vienen del backend)
    const allPermissions = [
      ...rolePermissions,
      ...(user.delegatedPermissions || []),
    ];

    // Parsear permiso requerido
    const [resource, action, requiredScope] = permission.split(':');

    for (const p of allPermissions) {
      const [pResource, pAction, pScope] = p.split(':');

      if (pResource !== resource || pAction !== action) continue;

      // Verificar scope
      if (scopeMatches(pScope as Scope, requiredScope as Scope, user, context)) {
        return true;
      }
    }

    return false;
  };

  /**
   * Verifica acceso a un recurso con accion especifica
   */
  const canAccess = (
    resource: Resource,
    action: Action,
    context?: PermissionContext
  ): boolean => {
    // Intentar con diferentes scopes
    const scopes = [Scope.ALL, Scope.COPROPIEDAD, Scope.OWN];

    for (const scope of scopes) {
      const permission = `${resource}:${action}:${scope}` as Permission;
      if (hasPermission(permission, context)) {
        return true;
      }
    }

    // Intentar sin scope
    const simplePermission = `${resource}:${action}` as Permission;
    return hasPermission(simplePermission, context);
  };

  /**
   * Shortcuts comunes
   */
  const can = {
    create: (resource: Resource, ctx?: PermissionContext) =>
      canAccess(resource, Action.CREATE, ctx),
    read: (resource: Resource, ctx?: PermissionContext) =>
      canAccess(resource, Action.READ, ctx),
    update: (resource: Resource, ctx?: PermissionContext) =>
      canAccess(resource, Action.UPDATE, ctx),
    delete: (resource: Resource, ctx?: PermissionContext) =>
      canAccess(resource, Action.DELETE, ctx),
    manage: (resource: Resource, ctx?: PermissionContext) =>
      canAccess(resource, Action.MANAGE, ctx),
  };

  return {
    hasPermission,
    canAccess,
    can,
    // Helpers de rol
    isAdmin: user?.role === Role.ADMIN,
    isResident: user?.role === Role.RESIDENT,
  };
}

function scopeMatches(
  grantedScope: Scope,
  requiredScope: Scope,
  user: User,
  context?: PermissionContext
): boolean {
  // ALL permite todo
  if (grantedScope === Scope.ALL) return true;

  // COPROPIEDAD: verificar que el usuario pertenece
  if (grantedScope === Scope.COPROPIEDAD && context?.copropiedadId) {
    return user.copropiedadIds?.includes(context.copropiedadId) ?? false;
  }

  // OWN: verificar que el recurso pertenece al usuario
  if (grantedScope === Scope.OWN) {
    if (context?.resourceOwnerId) {
      return user.id === context.resourceOwnerId;
    }
    // Si no hay contexto, asumimos que es recurso propio
    return true;
  }

  return grantedScope === requiredScope;
}

// lib/routes.ts
import { Role } from '@/types/auth';

export const ROUTES = {
  PUBLIC: {
    LOGIN: '/login',
    REGISTRO: '/registro',
    RECUPERAR_PASSWORD: '/recuperar-password',
  },
  ADMIN: {
    DASHBOARD: '/admin/dashboard',
    USUARIOS: '/admin/usuarios',
    COPROPIEDADES: '/admin/copropiedades',
    OBJETIVOS: '/admin/objetivos',
    REPORTES: '/admin/reportes',
    AUDITORIA: '/admin/auditoria',
    CONFIGURACION: '/admin/configuracion',
  },
  RESIDENT: {
    INICIO: '/resident/inicio',
    OBJETIVOS: '/resident/objetivos',
    MIS_APORTES: '/resident/mis-aportes',
    PQR: '/resident/pqr',
    PERFIL: '/resident/perfil',
  },
} as const;

export function getHomeRoute(role: Role): string {
  switch (role) {
    case Role.ADMIN:
      return ROUTES.ADMIN.DASHBOARD;
    case Role.RESIDENT:
      return ROUTES.RESIDENT.INICIO;
    default:
      return ROUTES.PUBLIC.LOGIN;
  }
}

// Uso en componentes:
// const { can, hasPermission } = usePermissions();
//
// if (can.create(Resource.OBJETIVOS, { copropiedadId })) {
//   // Mostrar boton crear
// }
//
// <ShowForPermission permission="reportes:export:copropiedad">
//   <ExportButton />
// </ShowForPermission>
```

## Testing

- [ ] hasPermission retorna valores correctos con scope
- [ ] canAccess verifica multiples scopes
- [ ] Permisos delegados se consideran
- [ ] Contexto de copropiedad funciona
- [ ] Contexto de resourceOwner funciona
- [ ] Permisos sincronizados con backend
