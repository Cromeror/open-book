# OB-003-B-001: Crear entidad Apartment con TypeORM

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-003 - Gestion de Copropiedades y Apartamentos |
| Story | OB-003-B - Modelo y gestion de apartamentos |
| Status | pending |
| Priority | critical |
| Created | 2025-12-31 |
| Updated | 2026-01-09 |
| Labels | task, entidad, typeorm, apartamento |
| Depends on | OB-003-A-001, OB-003-A-004 |
| Assigned | unassigned |

## Descripcion

Crear la entidad Apartment con decoradores TypeORM segun la seccion 4.3 del SUMMARY.md: numero de apartamento, torre/bloque (opcional), y estado.

## Contexto Tecnico

### Archivos a crear
- `apps/api/src/entities/apartment.entity.ts`
- `apps/api/src/migrations/XXXXXX-CreateApartmentsTable.ts`

### Archivos a modificar
- `apps/api/src/entities/condominium.entity.ts` - Agregar relacion apartments
- `apps/api/src/entities/index.ts` - Exportar nueva entidad

### Prerequisitos
- Entidad Tower debe existir (OB-003-A-004) para relacion opcional

## Criterios de Aceptacion

- [ ] Entidad Apartment creada con decoradores TypeORM
- [ ] Campos: number (string), floor (opcional), towerId (opcional)
- [ ] Relacion con Condominium (requerida)
- [ ] Relacion con Tower (opcional)
- [ ] Campo isActive para soft delete
- [ ] Indice unico: (condominiumId, towerId, number)
- [ ] Hereda campos de auditoria de BaseEntity
- [ ] Migracion creada y aplicada

## Notas de Implementacion

### Entidad Apartment (nombrado en ingles segun CLAUDE.md)

```typescript
// apps/api/src/entities/apartment.entity.ts
import { Entity, Column, ManyToOne, OneToMany, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from './base.entity';
import { Condominium } from './condominium.entity';
import { Tower } from './tower.entity';

@Entity('apartments')
@Index('idx_apartments_unique', ['condominiumId', 'towerId', 'number'], { unique: true })
export class Apartment extends BaseEntity {
  @Column({ type: 'varchar', length: 20 })
  number!: string;

  @Column({ type: 'integer', nullable: true })
  floor?: number;

  @Column({ name: 'condominium_id', type: 'uuid' })
  @Index('idx_apartments_condominium')
  condominiumId!: string;

  @ManyToOne(() => Condominium, (c) => c.apartments)
  @JoinColumn({ name: 'condominium_id' })
  condominium!: Condominium;

  @Column({ name: 'tower_id', type: 'uuid', nullable: true })
  @Index('idx_apartments_tower')
  towerId?: string;

  @ManyToOne(() => Tower, (t) => t.apartments, { nullable: true })
  @JoinColumn({ name: 'tower_id' })
  tower?: Tower;

  @Column({ name: 'is_active', type: 'boolean', default: true })
  isActive!: boolean;

  // Relaciones futuras (agregar cuando existan las entidades)
  // @OneToMany(() => ApartmentResident, (ar) => ar.apartment)
  // residents: ApartmentResident[];

  // @OneToMany(() => Commitment, (c) => c.apartment)
  // commitments: Commitment[];

  // @OneToMany(() => Contribution, (c) => c.apartment)
  // contributions: Contribution[];
}
```

### Agregar relacion en Condominium entity

```typescript
// Agregar a apps/api/src/entities/condominium.entity.ts
@OneToMany('Apartment', 'condominium')
apartments!: Apartment[];
```

### Mapeo de Nombres

| Documentacion (Espanol) | Implementacion (Ingles) | Columna BD |
|-------------------------|-------------------------|------------|
| numero | number | number |
| piso | floor | floor |
| copropiedadId | condominiumId | condominium_id |
| torreId | towerId | tower_id |
| isActive | isActive | is_active |

### Migracion

```typescript
// Crear migracion con: pnpm nx run api:migration:generate -- -n CreateApartmentsTable
export class CreateApartmentsTable implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: 'apartments',
        columns: [
          { name: 'id', type: 'uuid', isPrimary: true, default: 'gen_random_uuid()' },
          { name: 'number', type: 'varchar', length: '20' },
          { name: 'floor', type: 'integer', isNullable: true },
          { name: 'condominium_id', type: 'uuid' },
          { name: 'tower_id', type: 'uuid', isNullable: true },
          { name: 'is_active', type: 'boolean', default: true },
          { name: 'created_at', type: 'timestamp with time zone', default: 'now()' },
          { name: 'created_by', type: 'uuid', isNullable: true },
          { name: 'updated_at', type: 'timestamp with time zone', default: 'now()' },
          { name: 'updated_by', type: 'uuid', isNullable: true },
          { name: 'deleted_at', type: 'timestamp with time zone', isNullable: true },
          { name: 'deleted_by', type: 'uuid', isNullable: true },
        ],
      }),
    );

    // FK a condominiums
    await queryRunner.createForeignKey('apartments', new TableForeignKey({
      columnNames: ['condominium_id'],
      referencedTableName: 'condominiums',
      referencedColumnNames: ['id'],
      onDelete: 'CASCADE',
    }));

    // FK a towers (opcional)
    await queryRunner.createForeignKey('apartments', new TableForeignKey({
      columnNames: ['tower_id'],
      referencedTableName: 'towers',
      referencedColumnNames: ['id'],
      onDelete: 'SET NULL',
    }));

    // Indice unico compuesto
    await queryRunner.createIndex('apartments', new TableIndex({
      name: 'idx_apartments_unique',
      columnNames: ['condominium_id', 'tower_id', 'number'],
      isUnique: true,
    }));
  }
}
```

## Testing

- [ ] Migracion se aplica sin errores
- [ ] Se puede crear apartamento sin torre
- [ ] Se puede crear apartamento con torre
- [ ] Duplicado en misma copropiedad/torre falla (409 Conflict)
- [ ] Apartamentos con mismo numero en diferentes torres funciona
