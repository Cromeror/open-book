# OB-002-C-004: Crear sistema de pools de usuarios

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-002 - Gestion de Usuarios y Autenticacion |
| Story | OB-002-C - Sistema de permisos por modulos |
| Status | pending |
| Priority | high |
| Created | 2025-12-31 |
| Updated | 2026-01-05 |
| Labels | task, pools, usuarios, permisos, grupos |
| Depends on | OB-002-C-001 |
| Assigned | unassigned |

## Descripcion

Implementar sistema de pools (grupos) de usuarios que permiten asignar permisos identicos a multiples usuarios. Un pool tiene acceso a modulos y permisos granulares que se aplican a todos sus miembros.

## Contexto Tecnico

### Archivos afectados
- `apps/api/src/modules/permissions/entities/user-pool.entity.ts`
- `apps/api/src/modules/permissions/entities/user-pool-member.entity.ts`
- `apps/api/src/modules/permissions/entities/pool-module.entity.ts`
- `apps/api/src/modules/permissions/entities/pool-permission.entity.ts`
- `apps/api/src/modules/permissions/pools.service.ts`
- `apps/api/src/modules/permissions/pools.controller.ts`
- `apps/api/src/modules/permissions/permissions.service.ts` (modificar)

### Enfoque tecnico
Los pools funcionan como plantillas de permisos. Un usuario hereda todos los permisos de los pools a los que pertenece, ademas de sus permisos directos.

## Criterios de Aceptacion

- [ ] Entidad UserPool creada
- [ ] Entidad UserPoolMember creada
- [ ] Entidad PoolModule creada
- [ ] Entidad PoolPermission creada
- [ ] SuperAdmin puede crear/editar/eliminar pools
- [ ] SuperAdmin puede agregar/remover usuarios de pools
- [ ] SuperAdmin puede asignar modulos a pools
- [ ] SuperAdmin puede asignar permisos granulares a pools
- [ ] Permisos de pool se verifican en hasModuleAccess
- [ ] Permisos de pool se verifican en hasPermission
- [ ] Un usuario puede pertenecer a multiples pools
- [ ] Todos los cambios quedan en auditoria

## Notas de Implementacion

```typescript
// user-pool.entity.ts
@Entity('user_pools')
export class UserPool extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;  // 'Administradores Edificio Centro'

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column()
  createdBy: string;  // SuperAdmin ID

  @Column({ default: true })
  isActive: boolean;

  @OneToMany(() => UserPoolMember, (m) => m.pool)
  members: UserPoolMember[];

  @OneToMany(() => PoolModule, (pm) => pm.pool)
  modules: PoolModule[];

  @OneToMany(() => PoolPermission, (pp) => pp.pool)
  permissions: PoolPermission[];
}

// user-pool-member.entity.ts
@Entity('user_pool_members')
export class UserPoolMember extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  @Index()
  poolId: string;

  @ManyToOne(() => UserPool, (p) => p.members)
  @JoinColumn({ name: 'poolId' })
  pool: UserPool;

  @Column()
  @Index()
  userId: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;

  @Column()
  addedBy: string;

  @Column({ type: 'timestamp' })
  addedAt: Date;

  // Unique: un usuario solo puede estar una vez en un pool
  @Index(['poolId', 'userId'], { unique: true })
}

// pool-module.entity.ts
@Entity('pool_modules')
export class PoolModule extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  @Index()
  poolId: string;

  @ManyToOne(() => UserPool, (p) => p.modules)
  @JoinColumn({ name: 'poolId' })
  pool: UserPool;

  @Column()
  @Index()
  moduleId: string;

  @ManyToOne(() => Module)
  @JoinColumn({ name: 'moduleId' })
  module: Module;

  @Column()
  grantedBy: string;

  @Column({ type: 'timestamp' })
  grantedAt: Date;

  // Unique: un modulo solo se asigna una vez a un pool
  @Index(['poolId', 'moduleId'], { unique: true })
}

// pool-permission.entity.ts
@Entity('pool_permissions')
export class PoolPermission extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  @Index()
  poolId: string;

  @ManyToOne(() => UserPool, (p) => p.permissions)
  @JoinColumn({ name: 'poolId' })
  pool: UserPool;

  @Column()
  @Index()
  modulePermissionId: string;

  @ManyToOne(() => ModulePermission)
  @JoinColumn({ name: 'modulePermissionId' })
  modulePermission: ModulePermission;

  @Column({
    type: 'enum',
    enum: Scope,
    default: Scope.OWN,
  })
  scope: Scope;

  @Column({ nullable: true })
  scopeId: string | null;

  @Column()
  grantedBy: string;

  @Column({ type: 'timestamp' })
  grantedAt: Date;

  // Unique por pool + permiso + scope
  @Index(['poolId', 'modulePermissionId', 'scope', 'scopeId'], { unique: true })
}

// pools.service.ts
@Injectable()
export class PoolsService {
  constructor(
    @InjectRepository(UserPool)
    private poolRepo: Repository<UserPool>,
    @InjectRepository(UserPoolMember)
    private memberRepo: Repository<UserPoolMember>,
    @InjectRepository(PoolModule)
    private poolModuleRepo: Repository<PoolModule>,
    @InjectRepository(PoolPermission)
    private poolPermissionRepo: Repository<PoolPermission>,
    private auditService: AuditService,
  ) {}

  /**
   * Crear nuevo pool
   */
  async create(
    superAdminId: string,
    dto: CreatePoolDto,
  ): Promise<UserPool> {
    const pool = this.poolRepo.create({
      name: dto.name,
      description: dto.description,
      createdBy: superAdminId,
      isActive: true,
    });

    await this.poolRepo.save(pool);

    await this.auditService.log({
      action: 'POOL_CREATED',
      entityType: 'UserPool',
      entityId: pool.id,
      userId: superAdminId,
      details: { name: dto.name },
    });

    return pool;
  }

  /**
   * Agregar usuario a pool
   */
  async addMember(
    superAdminId: string,
    poolId: string,
    userId: string,
  ): Promise<UserPoolMember> {
    // Verificar que no existe ya
    const existing = await this.memberRepo.findOne({
      where: { poolId, userId },
    });

    if (existing) {
      throw new ConflictException('Usuario ya es miembro del pool');
    }

    const member = this.memberRepo.create({
      poolId,
      userId,
      addedBy: superAdminId,
      addedAt: new Date(),
    });

    await this.memberRepo.save(member);

    await this.auditService.log({
      action: 'POOL_MEMBER_ADDED',
      entityType: 'UserPoolMember',
      entityId: member.id,
      userId: superAdminId,
      details: { poolId, targetUserId: userId },
    });

    return member;
  }

  /**
   * Remover usuario de pool
   */
  async removeMember(
    superAdminId: string,
    poolId: string,
    userId: string,
  ): Promise<void> {
    const member = await this.memberRepo.findOne({
      where: { poolId, userId },
    });

    if (!member) {
      throw new NotFoundException('Usuario no es miembro del pool');
    }

    await this.memberRepo.remove(member);

    await this.auditService.log({
      action: 'POOL_MEMBER_REMOVED',
      entityType: 'UserPoolMember',
      entityId: member.id,
      userId: superAdminId,
      details: { poolId, targetUserId: userId },
    });
  }

  /**
   * Asignar acceso a modulo al pool
   */
  async grantModuleAccess(
    superAdminId: string,
    poolId: string,
    moduleId: string,
  ): Promise<PoolModule> {
    const existing = await this.poolModuleRepo.findOne({
      where: { poolId, moduleId },
    });

    if (existing) {
      throw new ConflictException('Pool ya tiene acceso a este modulo');
    }

    const poolModule = this.poolModuleRepo.create({
      poolId,
      moduleId,
      grantedBy: superAdminId,
      grantedAt: new Date(),
    });

    await this.poolModuleRepo.save(poolModule);

    await this.auditService.log({
      action: 'POOL_MODULE_GRANTED',
      entityType: 'PoolModule',
      entityId: poolModule.id,
      userId: superAdminId,
      details: { poolId, moduleId },
    });

    return poolModule;
  }

  /**
   * Asignar permiso granular al pool
   */
  async grantPermission(
    superAdminId: string,
    poolId: string,
    dto: GrantPoolPermissionDto,
  ): Promise<PoolPermission> {
    // Verificar que el pool tiene acceso al modulo del permiso
    const modulePermission = await this.findModulePermission(dto.modulePermissionId);

    const hasModuleAccess = await this.poolModuleRepo.findOne({
      where: { poolId, moduleId: modulePermission.moduleId },
    });

    if (!hasModuleAccess) {
      throw new BadRequestException(
        'Pool debe tener acceso al modulo antes de asignar permisos granulares'
      );
    }

    const poolPermission = this.poolPermissionRepo.create({
      poolId,
      modulePermissionId: dto.modulePermissionId,
      scope: dto.scope,
      scopeId: dto.scopeId,
      grantedBy: superAdminId,
      grantedAt: new Date(),
    });

    await this.poolPermissionRepo.save(poolPermission);

    await this.auditService.log({
      action: 'POOL_PERMISSION_GRANTED',
      entityType: 'PoolPermission',
      entityId: poolPermission.id,
      userId: superAdminId,
      details: { poolId, ...dto },
    });

    return poolPermission;
  }

  /**
   * Obtener pools de un usuario
   */
  async getUserPools(userId: string): Promise<UserPool[]> {
    return this.poolRepo
      .createQueryBuilder('p')
      .innerJoin('p.members', 'm')
      .where('m.userId = :userId', { userId })
      .andWhere('p.isActive = true')
      .getMany();
  }

  /**
   * Verificar si usuario tiene acceso a modulo via algun pool
   */
  async hasModuleAccessViaPool(
    userId: string,
    moduleCode: string,
  ): Promise<boolean> {
    const result = await this.poolModuleRepo
      .createQueryBuilder('pm')
      .innerJoin('pm.pool', 'p')
      .innerJoin('p.members', 'm')
      .innerJoin('pm.module', 'mod')
      .where('m.userId = :userId', { userId })
      .andWhere('mod.code = :moduleCode', { moduleCode })
      .andWhere('p.isActive = true')
      .getOne();

    return !!result;
  }

  /**
   * Verificar si usuario tiene permiso via algun pool
   */
  async hasPermissionViaPool(
    userId: string,
    moduleCode: string,
    action: string,
    context?: { copropiedadId?: string },
  ): Promise<boolean> {
    const poolPermissions = await this.poolPermissionRepo
      .createQueryBuilder('pp')
      .innerJoin('pp.pool', 'p')
      .innerJoin('p.members', 'm')
      .innerJoin('pp.modulePermission', 'mp')
      .innerJoin('mp.module', 'mod')
      .where('m.userId = :userId', { userId })
      .andWhere('mod.code = :moduleCode', { moduleCode })
      .andWhere('mp.code = :action', { action })
      .andWhere('p.isActive = true')
      .getMany();

    // Verificar si alguno de los permisos coincide con el contexto
    for (const pp of poolPermissions) {
      if (this.scopeMatches(pp.scope, pp.scopeId, context)) {
        return true;
      }
    }

    return false;
  }

  private scopeMatches(
    grantedScope: Scope,
    grantedScopeId: string | null,
    context?: { copropiedadId?: string },
  ): boolean {
    if (grantedScope === Scope.ALL) return true;

    if (grantedScope === Scope.COPROPIEDAD && context?.copropiedadId) {
      return grantedScopeId === context.copropiedadId;
    }

    if (grantedScope === Scope.OWN) {
      return true; // La verificacion final se hace en el servicio
    }

    return false;
  }
}

// pools.controller.ts
@Controller('api/admin/pools')
@UseGuards(JwtAuthGuard, SuperAdminGuard)
export class PoolsController {
  constructor(private poolsService: PoolsService) {}

  @Post()
  async create(
    @CurrentUser() superAdmin: User,
    @Body() dto: CreatePoolDto,
  ) {
    return this.poolsService.create(superAdmin.id, dto);
  }

  @Get()
  async findAll() {
    return this.poolsService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.poolsService.findOne(id);
  }

  @Post(':id/members')
  async addMember(
    @CurrentUser() superAdmin: User,
    @Param('id') poolId: string,
    @Body() dto: AddMemberDto,
  ) {
    return this.poolsService.addMember(superAdmin.id, poolId, dto.userId);
  }

  @Delete(':id/members/:userId')
  async removeMember(
    @CurrentUser() superAdmin: User,
    @Param('id') poolId: string,
    @Param('userId') userId: string,
  ) {
    return this.poolsService.removeMember(superAdmin.id, poolId, userId);
  }

  @Post(':id/modules')
  async grantModuleAccess(
    @CurrentUser() superAdmin: User,
    @Param('id') poolId: string,
    @Body() dto: GrantModuleDto,
  ) {
    return this.poolsService.grantModuleAccess(superAdmin.id, poolId, dto.moduleId);
  }

  @Post(':id/permissions')
  async grantPermission(
    @CurrentUser() superAdmin: User,
    @Param('id') poolId: string,
    @Body() dto: GrantPoolPermissionDto,
  ) {
    return this.poolsService.grantPermission(superAdmin.id, poolId, dto);
  }
}
```

## DTOs

```typescript
// create-pool.dto.ts
export class CreatePoolDto {
  @IsString()
  @MinLength(3)
  @MaxLength(100)
  name: string;

  @IsOptional()
  @IsString()
  @MaxLength(500)
  description?: string;
}

// add-member.dto.ts
export class AddMemberDto {
  @IsUUID()
  userId: string;
}

// grant-module.dto.ts
export class GrantModuleDto {
  @IsUUID()
  moduleId: string;
}

// grant-pool-permission.dto.ts
export class GrantPoolPermissionDto {
  @IsUUID()
  modulePermissionId: string;

  @IsEnum(Scope)
  scope: Scope;

  @IsOptional()
  @IsUUID()
  scopeId?: string;
}
```

## Testing

- [ ] SuperAdmin puede crear pool
- [ ] SuperAdmin puede agregar miembro a pool
- [ ] SuperAdmin puede remover miembro de pool
- [ ] SuperAdmin puede asignar modulo a pool
- [ ] SuperAdmin puede asignar permiso a pool
- [ ] No se puede asignar permiso sin tener modulo
- [ ] Usuario hereda acceso a modulo de pool
- [ ] Usuario hereda permisos de pool
- [ ] Usuario puede pertenecer a multiples pools
- [ ] Permisos se acumulan de todos los pools
- [ ] Todas las acciones quedan en auditoria
