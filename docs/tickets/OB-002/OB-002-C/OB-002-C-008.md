# OB-002-C-008: Crear endpoints de gestion de permisos (superadmin)

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-002 - Gestion de Usuarios y Autenticacion |
| Story | OB-002-C - Sistema de permisos por modulos |
| Status | done |
| Priority | high |
| Created | 2026-01-05 |
| Updated | 2026-01-05 |
| Labels | task, api, superadmin, permisos, endpoints |
| Depends on | OB-002-C-001, OB-002-C-004, OB-002-C-006 |
| Assigned | unassigned |

## Descripcion

Crear endpoints REST que permiten al SuperAdmin gestionar permisos de usuarios: asignar/revocar acceso a modulos, otorgar/revocar permisos granulares, y consultar permisos efectivos de usuarios.

## Contexto Tecnico

### Archivos afectados
- `apps/api/src/modules/permissions/admin-permissions.controller.ts`
- `apps/api/src/modules/permissions/admin-permissions.service.ts`
- `apps/api/src/modules/permissions/dto/*.dto.ts`
- `apps/api/src/modules/permissions/guards/superadmin.guard.ts`

### Enfoque tecnico
Todos los endpoints requieren autenticacion como SuperAdmin. Cada accion se registra en auditoria.

## Criterios de Aceptacion

- [ ] Guard SuperAdminGuard implementado
- [ ] Endpoints de gestion de modulos de usuario
- [ ] Endpoints de gestion de permisos granulares
- [ ] Endpoint para ver permisos efectivos de usuario
- [ ] Endpoint para listar modulos disponibles
- [ ] Todas las acciones registradas en auditoria
- [ ] Validacion de datos con class-validator
- [ ] Documentacion Swagger de endpoints

## Notas de Implementacion

### Guard de SuperAdmin

```typescript
// guards/superadmin.guard.ts
@Injectable()
export class SuperAdminGuard implements CanActivate {
  constructor(
    private configService: ConfigService,
    private reflector: Reflector,
  ) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      throw new UnauthorizedException('No autenticado');
    }

    const superAdminId = this.configService.get('SUPER_ADMIN_ID');

    if (user.id !== superAdminId) {
      throw new ForbiddenException('Solo el SuperAdmin puede realizar esta accion');
    }

    return true;
  }
}
```

### Controller Principal

```typescript
// admin-permissions.controller.ts
@Controller('api/admin/permissions')
@UseGuards(JwtAuthGuard, SuperAdminGuard)
@ApiTags('Admin - Permisos')
@ApiBearerAuth()
export class AdminPermissionsController {
  constructor(private adminPermissionsService: AdminPermissionsService) {}

  // ============ MODULOS ============

  @Get('modules')
  @ApiOperation({ summary: 'Listar todos los modulos disponibles' })
  async getModules() {
    return this.adminPermissionsService.getAllModules();
  }

  @Get('modules/:moduleCode/permissions')
  @ApiOperation({ summary: 'Listar permisos de un modulo' })
  async getModulePermissions(@Param('moduleCode') moduleCode: string) {
    return this.adminPermissionsService.getModulePermissions(moduleCode);
  }

  // ============ PERMISOS DE USUARIO ============

  @Get('users/:userId/permissions')
  @ApiOperation({ summary: 'Ver permisos efectivos de un usuario' })
  async getUserEffectivePermissions(@Param('userId') userId: string) {
    return this.adminPermissionsService.getUserEffectivePermissions(userId);
  }

  @Get('users/:userId/modules')
  @ApiOperation({ summary: 'Ver modulos asignados a un usuario' })
  async getUserModules(@Param('userId') userId: string) {
    return this.adminPermissionsService.getUserModules(userId);
  }

  @Post('users/:userId/modules')
  @ApiOperation({ summary: 'Asignar acceso a modulo a usuario' })
  async grantUserModuleAccess(
    @CurrentUser() superAdmin: User,
    @Param('userId') userId: string,
    @Body() dto: GrantModuleAccessDto,
  ) {
    return this.adminPermissionsService.grantModuleAccess(
      superAdmin.id,
      userId,
      dto,
    );
  }

  @Delete('users/:userId/modules/:moduleId')
  @ApiOperation({ summary: 'Revocar acceso a modulo de usuario' })
  async revokeUserModuleAccess(
    @CurrentUser() superAdmin: User,
    @Param('userId') userId: string,
    @Param('moduleId') moduleId: string,
  ) {
    return this.adminPermissionsService.revokeModuleAccess(
      superAdmin.id,
      userId,
      moduleId,
    );
  }

  @Post('users/:userId/permissions')
  @ApiOperation({ summary: 'Otorgar permiso granular a usuario' })
  async grantUserPermission(
    @CurrentUser() superAdmin: User,
    @Param('userId') userId: string,
    @Body() dto: GrantPermissionDto,
  ) {
    return this.adminPermissionsService.grantPermission(
      superAdmin.id,
      userId,
      dto,
    );
  }

  @Delete('users/:userId/permissions/:permissionId')
  @ApiOperation({ summary: 'Revocar permiso granular de usuario' })
  async revokeUserPermission(
    @CurrentUser() superAdmin: User,
    @Param('userId') userId: string,
    @Param('permissionId') permissionId: string,
  ) {
    return this.adminPermissionsService.revokePermission(
      superAdmin.id,
      userId,
      permissionId,
    );
  }

  // ============ BUSQUEDA ============

  @Get('users')
  @ApiOperation({ summary: 'Buscar usuarios con filtros' })
  async searchUsers(@Query() query: SearchUsersDto) {
    return this.adminPermissionsService.searchUsers(query);
  }

  @Get('users/by-module/:moduleCode')
  @ApiOperation({ summary: 'Listar usuarios con acceso a un modulo' })
  async getUsersByModule(@Param('moduleCode') moduleCode: string) {
    return this.adminPermissionsService.getUsersByModule(moduleCode);
  }
}
```

### Service

```typescript
// admin-permissions.service.ts
@Injectable()
export class AdminPermissionsService {
  constructor(
    @InjectRepository(Module)
    private moduleRepo: Repository<Module>,
    @InjectRepository(ModulePermission)
    private modulePermissionRepo: Repository<ModulePermission>,
    @InjectRepository(UserModule)
    private userModuleRepo: Repository<UserModule>,
    @InjectRepository(UserPermission)
    private userPermissionRepo: Repository<UserPermission>,
    @InjectRepository(User)
    private userRepo: Repository<User>,
    private poolsService: PoolsService,
    private auditService: AuditService,
    private cacheService: PermissionsCacheService,
  ) {}

  /**
   * Obtiene todos los modulos con sus permisos
   */
  async getAllModules(): Promise<Module[]> {
    return this.moduleRepo.find({
      where: { isActive: true },
      relations: ['permissions'],
      order: { name: 'ASC' },
    });
  }

  /**
   * Obtiene permisos de un modulo especifico
   */
  async getModulePermissions(moduleCode: string): Promise<ModulePermission[]> {
    const module = await this.moduleRepo.findOne({
      where: { code: moduleCode, isActive: true },
    });

    if (!module) {
      throw new NotFoundException(`Modulo '${moduleCode}' no encontrado`);
    }

    return this.modulePermissionRepo.find({
      where: { moduleId: module.id },
      order: { code: 'ASC' },
    });
  }

  /**
   * Obtiene permisos efectivos de un usuario (directos + pools)
   */
  async getUserEffectivePermissions(userId: string): Promise<{
    modules: { module: Module; source: 'direct' | 'pool'; poolName?: string }[];
    permissions: {
      permission: ModulePermission;
      scope: Scope;
      scopeId?: string;
      source: 'direct' | 'pool';
      poolName?: string;
    }[];
  }> {
    // Modulos directos
    const directModules = await this.userModuleRepo.find({
      where: { userId, isActive: true },
      relations: ['module'],
    });

    // Modulos via pools
    const userPools = await this.poolsService.getUserPools(userId);
    const poolModules: { module: Module; poolName: string }[] = [];

    for (const pool of userPools) {
      const modules = await this.poolsService.getPoolModules(pool.id);
      for (const pm of modules) {
        poolModules.push({ module: pm.module, poolName: pool.name });
      }
    }

    // Permisos directos
    const directPermissions = await this.userPermissionRepo.find({
      where: { userId, isActive: true },
      relations: ['modulePermission', 'modulePermission.module'],
    });

    // Permisos via pools
    const poolPermissions: {
      permission: ModulePermission;
      scope: Scope;
      scopeId?: string;
      poolName: string;
    }[] = [];

    for (const pool of userPools) {
      const permissions = await this.poolsService.getPoolPermissions(pool.id);
      for (const pp of permissions) {
        poolPermissions.push({
          permission: pp.modulePermission,
          scope: pp.scope,
          scopeId: pp.scopeId,
          poolName: pool.name,
        });
      }
    }

    return {
      modules: [
        ...directModules.map((um) => ({
          module: um.module,
          source: 'direct' as const,
        })),
        ...poolModules.map((pm) => ({
          module: pm.module,
          source: 'pool' as const,
          poolName: pm.poolName,
        })),
      ],
      permissions: [
        ...directPermissions.map((up) => ({
          permission: up.modulePermission,
          scope: up.scope,
          scopeId: up.scopeId,
          source: 'direct' as const,
        })),
        ...poolPermissions.map((pp) => ({
          permission: pp.permission,
          scope: pp.scope,
          scopeId: pp.scopeId,
          source: 'pool' as const,
          poolName: pp.poolName,
        })),
      ],
    };
  }

  /**
   * Asigna acceso a modulo a usuario
   */
  async grantModuleAccess(
    superAdminId: string,
    userId: string,
    dto: GrantModuleAccessDto,
  ): Promise<UserModule> {
    // Verificar que el modulo existe
    const module = await this.moduleRepo.findOne({
      where: { id: dto.moduleId, isActive: true },
    });

    if (!module) {
      throw new NotFoundException('Modulo no encontrado');
    }

    // Verificar que el usuario existe
    const user = await this.userRepo.findOne({ where: { id: userId } });
    if (!user) {
      throw new NotFoundException('Usuario no encontrado');
    }

    // Verificar que no tiene ya el acceso
    const existing = await this.userModuleRepo.findOne({
      where: { userId, moduleId: dto.moduleId, isActive: true },
    });

    if (existing) {
      throw new ConflictException('Usuario ya tiene acceso a este modulo');
    }

    const userModule = this.userModuleRepo.create({
      userId,
      moduleId: dto.moduleId,
      grantedBy: superAdminId,
      grantedAt: new Date(),
      expiresAt: dto.expiresAt ? new Date(dto.expiresAt) : null,
      isActive: true,
    });

    await this.userModuleRepo.save(userModule);

    // Invalidar cache
    this.cacheService.invalidate(userId);

    // Auditoria
    await this.auditService.log({
      action: 'MODULE_ACCESS_GRANTED',
      entityType: 'UserModule',
      entityId: userModule.id,
      userId: superAdminId,
      details: {
        targetUserId: userId,
        moduleId: dto.moduleId,
        moduleCode: module.code,
      },
    });

    return userModule;
  }

  /**
   * Revoca acceso a modulo de usuario
   */
  async revokeModuleAccess(
    superAdminId: string,
    userId: string,
    moduleId: string,
  ): Promise<void> {
    const userModule = await this.userModuleRepo.findOne({
      where: { userId, moduleId, isActive: true },
      relations: ['module'],
    });

    if (!userModule) {
      throw new NotFoundException('Usuario no tiene acceso a este modulo');
    }

    userModule.isActive = false;
    await this.userModuleRepo.save(userModule);

    // Tambien desactivar permisos granulares del modulo
    await this.userPermissionRepo
      .createQueryBuilder()
      .update()
      .set({ isActive: false })
      .where('userId = :userId', { userId })
      .andWhere('modulePermissionId IN (SELECT id FROM module_permissions WHERE moduleId = :moduleId)', { moduleId })
      .execute();

    // Invalidar cache
    this.cacheService.invalidate(userId);

    // Auditoria
    await this.auditService.log({
      action: 'MODULE_ACCESS_REVOKED',
      entityType: 'UserModule',
      entityId: userModule.id,
      userId: superAdminId,
      details: {
        targetUserId: userId,
        moduleId,
        moduleCode: userModule.module.code,
      },
    });
  }

  /**
   * Otorga permiso granular a usuario
   */
  async grantPermission(
    superAdminId: string,
    userId: string,
    dto: GrantPermissionDto,
  ): Promise<UserPermission> {
    // Verificar que el permiso existe
    const modulePermission = await this.modulePermissionRepo.findOne({
      where: { id: dto.modulePermissionId },
      relations: ['module'],
    });

    if (!modulePermission) {
      throw new NotFoundException('Permiso no encontrado');
    }

    // Verificar que el usuario tiene acceso al modulo
    const hasModuleAccess = await this.userModuleRepo.findOne({
      where: {
        userId,
        moduleId: modulePermission.moduleId,
        isActive: true,
      },
    });

    // O tiene acceso via pool
    const hasPoolAccess = await this.poolsService.hasModuleAccessViaPool(
      userId,
      modulePermission.module.code,
    );

    if (!hasModuleAccess && !hasPoolAccess) {
      throw new BadRequestException(
        'Usuario debe tener acceso al modulo antes de asignar permisos granulares',
      );
    }

    // Verificar que no tiene ya el permiso
    const existing = await this.userPermissionRepo.findOne({
      where: {
        userId,
        modulePermissionId: dto.modulePermissionId,
        scope: dto.scope,
        scopeId: dto.scopeId || IsNull(),
        isActive: true,
      },
    });

    if (existing) {
      throw new ConflictException('Usuario ya tiene este permiso');
    }

    const userPermission = this.userPermissionRepo.create({
      userId,
      modulePermissionId: dto.modulePermissionId,
      scope: dto.scope,
      scopeId: dto.scopeId || null,
      grantedBy: superAdminId,
      grantedAt: new Date(),
      expiresAt: dto.expiresAt ? new Date(dto.expiresAt) : null,
      isActive: true,
    });

    await this.userPermissionRepo.save(userPermission);

    // Invalidar cache
    this.cacheService.invalidate(userId);

    // Auditoria
    await this.auditService.log({
      action: 'PERMISSION_GRANTED',
      entityType: 'UserPermission',
      entityId: userPermission.id,
      userId: superAdminId,
      details: {
        targetUserId: userId,
        moduleCode: modulePermission.module.code,
        permissionCode: modulePermission.code,
        scope: dto.scope,
        scopeId: dto.scopeId,
      },
    });

    return userPermission;
  }

  /**
   * Revoca permiso granular de usuario
   */
  async revokePermission(
    superAdminId: string,
    userId: string,
    permissionId: string,
  ): Promise<void> {
    const userPermission = await this.userPermissionRepo.findOne({
      where: { id: permissionId, userId, isActive: true },
      relations: ['modulePermission', 'modulePermission.module'],
    });

    if (!userPermission) {
      throw new NotFoundException('Permiso no encontrado');
    }

    userPermission.isActive = false;
    await this.userPermissionRepo.save(userPermission);

    // Invalidar cache
    this.cacheService.invalidate(userId);

    // Auditoria
    await this.auditService.log({
      action: 'PERMISSION_REVOKED',
      entityType: 'UserPermission',
      entityId: userPermission.id,
      userId: superAdminId,
      details: {
        targetUserId: userId,
        moduleCode: userPermission.modulePermission.module.code,
        permissionCode: userPermission.modulePermission.code,
      },
    });
  }
}
```

### DTOs

```typescript
// grant-module-access.dto.ts
export class GrantModuleAccessDto {
  @IsUUID()
  @ApiProperty({ description: 'ID del modulo' })
  moduleId: string;

  @IsOptional()
  @IsDateString()
  @ApiProperty({ description: 'Fecha de expiracion (opcional)', required: false })
  expiresAt?: string;
}

// grant-permission.dto.ts
export class GrantPermissionDto {
  @IsUUID()
  @ApiProperty({ description: 'ID del permiso de modulo' })
  modulePermissionId: string;

  @IsEnum(Scope)
  @ApiProperty({ description: 'Scope del permiso', enum: Scope })
  scope: Scope;

  @IsOptional()
  @IsUUID()
  @ApiProperty({ description: 'ID de copropiedad si scope=copropiedad', required: false })
  scopeId?: string;

  @IsOptional()
  @IsDateString()
  @ApiProperty({ description: 'Fecha de expiracion (opcional)', required: false })
  expiresAt?: string;
}

// search-users.dto.ts
export class SearchUsersDto {
  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsUUID()
  copropiedadId?: string;

  @IsOptional()
  @IsString()
  moduleCode?: string;

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 20;
}
```

## Endpoints Resumen

| Metodo | Ruta | Descripcion |
|--------|------|-------------|
| GET | /api/admin/permissions/modules | Listar modulos |
| GET | /api/admin/permissions/modules/:code/permissions | Permisos de modulo |
| GET | /api/admin/permissions/users/:id/permissions | Permisos efectivos de usuario |
| GET | /api/admin/permissions/users/:id/modules | Modulos de usuario |
| POST | /api/admin/permissions/users/:id/modules | Asignar modulo |
| DELETE | /api/admin/permissions/users/:id/modules/:moduleId | Revocar modulo |
| POST | /api/admin/permissions/users/:id/permissions | Otorgar permiso |
| DELETE | /api/admin/permissions/users/:id/permissions/:permId | Revocar permiso |
| GET | /api/admin/permissions/users | Buscar usuarios |
| GET | /api/admin/permissions/users/by-module/:code | Usuarios por modulo |

## Testing

- [ ] Solo SuperAdmin puede acceder a endpoints
- [ ] Listar modulos retorna todos activos
- [ ] Asignar modulo funciona correctamente
- [ ] No se puede asignar modulo duplicado
- [ ] Revocar modulo tambien revoca permisos
- [ ] Otorgar permiso requiere acceso al modulo
- [ ] No se puede otorgar permiso duplicado
- [ ] Revocar permiso invalida cache
- [ ] Permisos efectivos incluyen directos y pools
- [ ] Todas las acciones quedan en auditoria
- [ ] Documentacion Swagger correcta
