# OB-002-C-007: Implementar cache de permisos

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-002 - Gestion de Usuarios y Autenticacion |
| Story | OB-002-C - Sistema de roles y permisos granulares |
| Status | pending |
| Priority | medium |
| Created | 2026-01-05 |
| Updated | 2026-01-05 |
| Labels | task, permisos, cache, performance |
| Depends on | OB-002-C-005, OB-002-C-006 |
| Assigned | unassigned |

## Descripcion

Implementar sistema de cache para permisos de usuario, evitando consultas repetitivas a la base de datos y mejorando el rendimiento del sistema de autorizacion.

## Contexto Tecnico

### Archivos afectados
- `apps/api/src/auth/permissions/permissions-cache.service.ts`
- `apps/api/src/auth/permissions/permissions.service.ts` (modificar)
- `apps/api/src/auth/permissions/permissions.module.ts`

### Enfoque tecnico
Cache en memoria con invalidacion por usuario. Usar Map o cache-manager de NestJS. TTL configurable.

## Criterios de Aceptacion

- [ ] Cache de permisos por usuario implementado
- [ ] TTL configurable (default 5 minutos)
- [ ] Invalidacion al cambiar permisos delegados
- [ ] Invalidacion al cambiar rol de usuario
- [ ] Invalidacion al asociar/desasociar de copropiedad
- [ ] Metrica de hit/miss ratio (opcional)

## Notas de Implementacion

```typescript
// permissions-cache.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

interface CachedPermissions {
  rolePermissions: string[];
  delegatedPermissions: string[];
  copropiedadIds: string[];
  cachedAt: number;
}

@Injectable()
export class PermissionsCacheService {
  private cache = new Map<string, CachedPermissions>();
  private readonly ttlMs: number;

  constructor(private configService: ConfigService) {
    this.ttlMs = this.configService.get('PERMISSIONS_CACHE_TTL_MS', 300000); // 5 min default
  }

  /**
   * Obtiene permisos cacheados del usuario
   */
  get(userId: string): CachedPermissions | null {
    const cached = this.cache.get(userId);

    if (!cached) return null;

    // Verificar TTL
    if (Date.now() - cached.cachedAt > this.ttlMs) {
      this.cache.delete(userId);
      return null;
    }

    return cached;
  }

  /**
   * Guarda permisos en cache
   */
  set(userId: string, permissions: Omit<CachedPermissions, 'cachedAt'>): void {
    this.cache.set(userId, {
      ...permissions,
      cachedAt: Date.now(),
    });
  }

  /**
   * Invalida cache de un usuario especifico
   */
  invalidate(userId: string): void {
    this.cache.delete(userId);
  }

  /**
   * Invalida cache de todos los usuarios de una copropiedad
   * Usado cuando cambian permisos a nivel de copropiedad
   */
  invalidateByCopropiedad(copropiedadId: string): void {
    for (const [userId, cached] of this.cache.entries()) {
      if (cached.copropiedadIds.includes(copropiedadId)) {
        this.cache.delete(userId);
      }
    }
  }

  /**
   * Limpia todo el cache
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * Estadisticas del cache (para monitoring)
   */
  getStats(): { size: number; hitRate?: number } {
    return {
      size: this.cache.size,
    };
  }
}

// Modificar permissions.service.ts
@Injectable()
export class PermissionsService {
  constructor(
    private cacheService: PermissionsCacheService,
    @InjectRepository(UserPermission)
    private userPermissionRepo: Repository<UserPermission>,
  ) {}

  async getEffectivePermissions(userId: string): Promise<{
    rolePermissions: string[];
    delegatedPermissions: string[];
    copropiedadIds: string[];
  }> {
    // 1. Intentar obtener del cache
    const cached = this.cacheService.get(userId);
    if (cached) {
      return cached;
    }

    // 2. Cargar del repositorio
    const user = await this.userRepo.findOne({
      where: { id: userId },
      relations: ['copropiedades'],
    });

    if (!user) {
      throw new NotFoundException('Usuario no encontrado');
    }

    const rolePermissions = ROLE_PERMISSIONS[user.role] || [];

    const delegatedPermissions = await this.userPermissionRepo
      .createQueryBuilder('up')
      .select('up.permission')
      .where('up.userId = :userId', { userId })
      .andWhere('up.isActive = true')
      .andWhere('(up.expiresAt IS NULL OR up.expiresAt > :now)', {
        now: new Date(),
      })
      .getMany()
      .then((perms) => perms.map((p) => p.permission));

    const copropiedadIds = user.copropiedades?.map((c) => c.id) || [];

    const result = {
      rolePermissions,
      delegatedPermissions,
      copropiedadIds,
    };

    // 3. Guardar en cache
    this.cacheService.set(userId, result);

    return result;
  }

  async hasPermission(
    userId: string,
    permission: string,
    context?: { copropiedadId?: string; resourceOwnerId?: string },
  ): Promise<boolean> {
    const { rolePermissions, delegatedPermissions, copropiedadIds } =
      await this.getEffectivePermissions(userId);

    const allPermissions = [...rolePermissions, ...delegatedPermissions];

    // Buscar permiso compatible
    for (const p of allPermissions) {
      if (this.permissionMatches(p, permission, context, copropiedadIds)) {
        return true;
      }
    }

    return false;
  }

  private permissionMatches(
    granted: string,
    required: string,
    context?: { copropiedadId?: string; resourceOwnerId?: string },
    userCopropiedadIds?: string[],
  ): boolean {
    const [gResource, gAction, gScope] = granted.split(':');
    const [rResource, rAction] = required.split(':');

    if (gResource !== rResource || gAction !== rAction) {
      return false;
    }

    // Verificar scope
    if (gScope === 'all') return true;

    if (gScope === 'copropiedad' && context?.copropiedadId) {
      return userCopropiedadIds?.includes(context.copropiedadId) ?? false;
    }

    if (gScope === 'own' && context?.resourceOwnerId) {
      // Esta verificacion requiere el userId actual
      // Se maneja en el servicio que llama
      return true;
    }

    return false;
  }
}

// Event listeners para invalidacion
@Injectable()
export class PermissionsCacheInvalidator {
  constructor(private cacheService: PermissionsCacheService) {}

  @OnEvent('user.roleChanged')
  handleRoleChanged(payload: { userId: string }) {
    this.cacheService.invalidate(payload.userId);
  }

  @OnEvent('user.permissionGranted')
  @OnEvent('user.permissionRevoked')
  handlePermissionChanged(payload: { userId: string }) {
    this.cacheService.invalidate(payload.userId);
  }

  @OnEvent('user.copropiedadChanged')
  handleCopropiedadChanged(payload: { userId: string }) {
    this.cacheService.invalidate(payload.userId);
  }

  @OnEvent('copropiedad.permissionsChanged')
  handleCopropiedadPermissionsChanged(payload: { copropiedadId: string }) {
    this.cacheService.invalidateByCopropiedad(payload.copropiedadId);
  }
}
```

## Testing

- [ ] Cache hit evita consulta a BD
- [ ] Cache miss consulta BD y guarda
- [ ] TTL expira correctamente
- [ ] Invalidacion por usuario funciona
- [ ] Invalidacion por copropiedad funciona
- [ ] Eventos de cambio invalidan cache
