# OB-002-C-001: Definir estructura de modulos y permisos

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-002 - Gestion de Usuarios y Autenticacion |
| Story | OB-002-C - Sistema de permisos por modulos |
| Status | done |
| Priority | critical |
| Created | 2025-12-31 |
| Updated | 2026-01-05 |
| Labels | task, modulos, permisos, configuracion, granular |
| Depends on | OB-002-A-001 |
| Assigned | unassigned |

## Descripcion

Definir la estructura completa de modulos y permisos del sistema. Cada modulo representa una unidad funcional y tiene permisos granulares asociados. No existen roles predefinidos - los permisos se asignan individualmente o via pools.

## Contexto Tecnico

### Archivos afectados
- `apps/api/src/modules/permissions/entities/module.entity.ts`
- `apps/api/src/modules/permissions/entities/module-permission.entity.ts`
- `apps/api/src/modules/permissions/entities/user-module.entity.ts`
- `apps/api/src/modules/permissions/entities/user-permission.entity.ts`
- `apps/api/src/modules/permissions/permissions.enum.ts`
- `apps/api/src/modules/permissions/permissions.service.ts`
- `apps/api/src/modules/permissions/permissions.module.ts`

### Enfoque tecnico
Sistema de permisos basado en modulos con formato `modulo:accion`. Cada permiso puede tener un scope que limita el acceso a recursos especificos.

## Criterios de Aceptacion

- [ ] Entidad Module creada con TypeORM
- [ ] Entidad ModulePermission creada
- [ ] Entidad UserModule (acceso a modulo) creada
- [ ] Entidad UserPermission (permiso granular) creada
- [ ] Enum de acciones (create, read, update, delete, export, manage)
- [ ] Enum de scopes (own, copropiedad, all)
- [ ] Funcion isSuperAdmin(userId) implementada
- [ ] Funcion hasModuleAccess(userId, moduleCode) implementada
- [ ] Funcion hasPermission(userId, permission, context) implementada

## Notas de Implementacion

```typescript
// permissions.enum.ts

// Acciones posibles en cualquier modulo
export enum Action {
  CREATE = 'create',
  READ = 'read',
  UPDATE = 'update',
  DELETE = 'delete',
  EXPORT = 'export',
  MANAGE = 'manage',  // Accion administrativa especial
}

// Scopes de acceso
export enum Scope {
  OWN = 'own',              // Solo recursos propios
  COPROPIEDAD = 'copropiedad', // Recursos de su copropiedad
  ALL = 'all',              // Todos los recursos (solo via superadmin)
}

// Tipo de permiso completo
export type Permission = `${string}:${Action}` | `${string}:${Action}:${Scope}`;

// module.entity.ts
@Entity('modules')
export class Module extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  code: string;  // 'objetivos', 'aportes', 'pqr'

  @Column()
  name: string;  // 'Objetivos de Recaudo'

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({ default: true })
  isActive: boolean;

  @OneToMany(() => ModulePermission, (mp) => mp.module)
  permissions: ModulePermission[];
}

// module-permission.entity.ts
@Entity('module_permissions')
export class ModulePermission extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  @Index()
  moduleId: string;

  @ManyToOne(() => Module, (m) => m.permissions)
  @JoinColumn({ name: 'moduleId' })
  module: Module;

  @Column()
  code: string;  // 'create', 'read', 'update', 'delete'

  @Column()
  name: string;  // 'Crear objetivos'

  @Column({ type: 'text', nullable: true })
  description: string;

  // Unique constraint: un permiso por modulo
  @Index(['moduleId', 'code'], { unique: true })
}

// user-module.entity.ts
@Entity('user_modules')
export class UserModule extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  @Index()
  userId: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;

  @Column()
  @Index()
  moduleId: string;

  @ManyToOne(() => Module)
  @JoinColumn({ name: 'moduleId' })
  module: Module;

  @Column()
  grantedBy: string;  // SuperAdmin ID

  @Column({ type: 'timestamp' })
  grantedAt: Date;

  @Column({ type: 'timestamp', nullable: true })
  expiresAt: Date | null;

  @Column({ default: true })
  isActive: boolean;

  // Unique constraint: un usuario solo tiene un acceso por modulo
  @Index(['userId', 'moduleId'], { unique: true })
}

// user-permission.entity.ts
@Entity('user_permissions')
export class UserPermission extends BaseAuditEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  @Index()
  userId: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;

  @Column()
  @Index()
  modulePermissionId: string;

  @ManyToOne(() => ModulePermission)
  @JoinColumn({ name: 'modulePermissionId' })
  modulePermission: ModulePermission;

  @Column({
    type: 'enum',
    enum: Scope,
    default: Scope.OWN,
  })
  scope: Scope;

  @Column({ nullable: true })
  scopeId: string | null;  // ID de copropiedad si scope='copropiedad'

  @Column()
  grantedBy: string;

  @Column({ type: 'timestamp' })
  grantedAt: Date;

  @Column({ type: 'timestamp', nullable: true })
  expiresAt: Date | null;

  @Column({ default: true })
  isActive: boolean;

  // Unique constraint por usuario + permiso + scope
  @Index(['userId', 'modulePermissionId', 'scope', 'scopeId'], { unique: true })
}

// permissions.service.ts
@Injectable()
export class PermissionsService {
  constructor(
    private configService: ConfigService,
    @InjectRepository(Module)
    private moduleRepo: Repository<Module>,
    @InjectRepository(UserModule)
    private userModuleRepo: Repository<UserModule>,
    @InjectRepository(UserPermission)
    private userPermissionRepo: Repository<UserPermission>,
  ) {}

  /**
   * Verifica si el usuario es SuperAdmin
   */
  isSuperAdmin(userId: string): boolean {
    const superAdminId = this.configService.get('SUPER_ADMIN_ID');
    return userId === superAdminId;
  }

  /**
   * Verifica si el usuario tiene acceso a un modulo
   */
  async hasModuleAccess(userId: string, moduleCode: string): Promise<boolean> {
    // SuperAdmin tiene acceso a todo
    if (this.isSuperAdmin(userId)) return true;

    // Verificar acceso directo
    const directAccess = await this.userModuleRepo
      .createQueryBuilder('um')
      .innerJoin('um.module', 'm')
      .where('um.userId = :userId', { userId })
      .andWhere('m.code = :moduleCode', { moduleCode })
      .andWhere('um.isActive = true')
      .andWhere('(um.expiresAt IS NULL OR um.expiresAt > :now)', {
        now: new Date(),
      })
      .getOne();

    if (directAccess) return true;

    // Verificar acceso via pool (ver OB-002-C-004)
    return this.hasModuleAccessViaPool(userId, moduleCode);
  }

  /**
   * Verifica si el usuario tiene un permiso especifico
   */
  async hasPermission(
    userId: string,
    permission: string,  // 'objetivos:create'
    context?: { copropiedadId?: string; resourceOwnerId?: string },
  ): Promise<boolean> {
    // SuperAdmin tiene todos los permisos
    if (this.isSuperAdmin(userId)) return true;

    const [moduleCode, action] = permission.split(':');

    // 1. Verificar acceso al modulo
    const hasModule = await this.hasModuleAccess(userId, moduleCode);
    if (!hasModule) return false;

    // 2. Verificar permiso granular
    const userPermission = await this.userPermissionRepo
      .createQueryBuilder('up')
      .innerJoin('up.modulePermission', 'mp')
      .innerJoin('mp.module', 'm')
      .where('up.userId = :userId', { userId })
      .andWhere('m.code = :moduleCode', { moduleCode })
      .andWhere('mp.code = :action', { action })
      .andWhere('up.isActive = true')
      .andWhere('(up.expiresAt IS NULL OR up.expiresAt > :now)', {
        now: new Date(),
      })
      .getOne();

    if (!userPermission) {
      // Verificar via pool
      return this.hasPermissionViaPool(userId, permission, context);
    }

    // 3. Verificar scope
    return this.scopeMatches(userPermission.scope, userPermission.scopeId, context);
  }

  /**
   * Verifica si el scope otorgado permite acceso al contexto
   */
  private scopeMatches(
    grantedScope: Scope,
    grantedScopeId: string | null,
    context?: { copropiedadId?: string; resourceOwnerId?: string },
  ): boolean {
    // Scope ALL permite todo
    if (grantedScope === Scope.ALL) return true;

    // Scope COPROPIEDAD: verificar que coincide la copropiedad
    if (grantedScope === Scope.COPROPIEDAD && context?.copropiedadId) {
      return grantedScopeId === context.copropiedadId;
    }

    // Scope OWN: verificar que el recurso pertenece al usuario
    if (grantedScope === Scope.OWN && context?.resourceOwnerId) {
      // El resourceOwnerId debe coincidir con el userId
      // Esta verificacion se hace en el servicio que llama
      return true;
    }

    return false;
  }

  // Metodos para verificar permisos via pool (implementados en OB-002-C-004)
  private async hasModuleAccessViaPool(userId: string, moduleCode: string): Promise<boolean> {
    // TODO: Implementar en OB-002-C-004
    return false;
  }

  private async hasPermissionViaPool(
    userId: string,
    permission: string,
    context?: { copropiedadId?: string; resourceOwnerId?: string },
  ): Promise<boolean> {
    // TODO: Implementar en OB-002-C-004
    return false;
  }
}
```

## Modulos Iniciales

Los siguientes modulos se registran via migracion inicial:

```typescript
const INITIAL_MODULES = [
  {
    code: 'users',
    name: 'Gestion de Usuarios',
    description: 'Administracion de usuarios del sistema',
    permissions: ['read', 'update'],
  },
  {
    code: 'copropiedades',
    name: 'Copropiedades',
    description: 'Gestion de copropiedades',
    permissions: ['read', 'update'],
  },
  {
    code: 'apartamentos',
    name: 'Apartamentos',
    description: 'Gestion de apartamentos/unidades',
    permissions: ['create', 'read', 'update', 'delete'],
  },
  {
    code: 'objetivos',
    name: 'Objetivos de Recaudo',
    description: 'Definicion de metas de recaudo',
    permissions: ['create', 'read', 'update', 'delete'],
  },
  {
    code: 'actividades',
    name: 'Actividades de Recaudo',
    description: 'Rifas, donaciones, eventos',
    permissions: ['create', 'read', 'update', 'delete'],
  },
  {
    code: 'compromisos',
    name: 'Compromisos',
    description: 'Promesas de aporte',
    permissions: ['create', 'read', 'update'],
  },
  {
    code: 'aportes',
    name: 'Aportes Reales',
    description: 'Registro de contribuciones',
    permissions: ['create', 'read', 'update'],
  },
  {
    code: 'pqr',
    name: 'PQR',
    description: 'Peticiones, quejas y reclamos',
    permissions: ['create', 'read', 'manage'],
  },
  {
    code: 'reportes',
    name: 'Reportes',
    description: 'Generacion de reportes',
    permissions: ['read', 'export'],
  },
  {
    code: 'auditoria',
    name: 'Auditoria',
    description: 'Logs de auditoria del sistema',
    permissions: ['read'],
  },
  {
    code: 'notificaciones',
    name: 'Notificaciones',
    description: 'Sistema de notificaciones',
    permissions: ['read', 'create'],
  },
  {
    code: 'configuracion',
    name: 'Configuracion',
    description: 'Configuracion del sistema',
    permissions: ['read', 'update'],
  },
];
```

## Testing

- [ ] isSuperAdmin retorna true solo para el ID configurado
- [ ] hasModuleAccess retorna false si no tiene acceso
- [ ] hasModuleAccess retorna true si tiene acceso activo
- [ ] hasModuleAccess ignora accesos expirados
- [ ] hasPermission requiere acceso al modulo primero
- [ ] hasPermission verifica permiso granular
- [ ] hasPermission respeta scope de copropiedad
- [ ] hasPermission respeta scope own
- [ ] Entidades tienen relaciones correctas
