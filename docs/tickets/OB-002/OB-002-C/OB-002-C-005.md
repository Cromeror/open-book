# OB-002-C-005: Implementar permisos por contexto (scope)

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-002 - Gestion de Usuarios y Autenticacion |
| Story | OB-002-C - Sistema de roles y permisos granulares |
| Status | done |
| Priority | high |
| Created | 2026-01-05 |
| Updated | 2026-01-05 |
| Labels | task, permisos, scope, contexto, granular |
| Depends on | OB-002-C-001, OB-003-A |
| Assigned | unassigned |

## Descripcion

Implementar la verificacion de permisos basada en contexto (scope), permitiendo que los permisos se limiten a recursos especificos como "solo mi copropiedad" o "solo mis datos".

## Contexto Tecnico

### Archivos afectados
- `apps/api/src/auth/permissions/scope.service.ts`
- `apps/api/src/auth/permissions/scope.guard.ts`
- `apps/api/src/auth/decorators/check-scope.decorator.ts`

### Enfoque tecnico
Crear servicio que resuelve el scope de un request y verifica si el usuario tiene acceso al recurso solicitado.

## Criterios de Aceptacion

- [ ] ScopeService implementado con verificacion de contexto
- [ ] Scope OWN: usuario solo accede a sus recursos
- [ ] Scope COPROPIEDAD: usuario accede a recursos de su copropiedad
- [ ] Scope ALL: superadmin accede a todo
- [ ] Guard que extrae contexto del request (params, body)
- [ ] Decorador @CheckScope para usar en controllers

## Notas de Implementacion

```typescript
// scope.service.ts
import { Injectable } from '@nestjs/common';
import { Scope } from './permissions.enum';
import { User } from '../users/user.entity';

export interface ScopeContext {
  copropiedadId?: string;
  apartamentoId?: string;
  resourceOwnerId?: string;
}

@Injectable()
export class ScopeService {
  /**
   * Verifica si el usuario tiene acceso al contexto dado
   */
  async checkScope(
    user: User,
    requiredScope: Scope,
    context: ScopeContext,
  ): Promise<boolean> {
    switch (requiredScope) {
      case Scope.ALL:
        // Solo superadmin tiene scope ALL
        return user.isSuperAdmin === true;

      case Scope.COPROPIEDAD:
        return this.checkCopropiedadScope(user, context);

      case Scope.OWN:
        return this.checkOwnScope(user, context);

      default:
        return false;
    }
  }

  /**
   * Verifica acceso a nivel de copropiedad
   * Admin debe ser administrador de esa copropiedad
   * Residente debe pertenecer a esa copropiedad
   */
  private async checkCopropiedadScope(
    user: User,
    context: ScopeContext,
  ): Promise<boolean> {
    if (!context.copropiedadId) return false;

    // Verificar si el usuario esta asociado a la copropiedad
    const userCopropiedades = await this.getUserCopropiedades(user.id);
    return userCopropiedades.includes(context.copropiedadId);
  }

  /**
   * Verifica acceso a recursos propios
   */
  private checkOwnScope(user: User, context: ScopeContext): Promise<boolean> {
    // El recurso debe pertenecer al usuario
    if (context.resourceOwnerId) {
      return user.id === context.resourceOwnerId;
    }

    // Si hay apartamento, verificar que pertenece al usuario
    if (context.apartamentoId) {
      return this.userOwnsApartamento(user.id, context.apartamentoId);
    }

    return false;
  }

  /**
   * Extrae el contexto del request
   */
  extractContext(request: Request): ScopeContext {
    const params = request.params || {};
    const body = request.body || {};
    const query = request.query || {};

    return {
      copropiedadId:
        params.copropiedadId ||
        body.copropiedadId ||
        query.copropiedadId,
      apartamentoId:
        params.apartamentoId ||
        body.apartamentoId ||
        query.apartamentoId,
      resourceOwnerId:
        params.userId ||
        body.userId,
    };
  }

  private async getUserCopropiedades(userId: string): Promise<string[]> {
    // TODO: Implementar con repository
    return [];
  }

  private async userOwnsApartamento(
    userId: string,
    apartamentoId: string,
  ): Promise<boolean> {
    // TODO: Implementar con repository
    return false;
  }
}

// scope.guard.ts
@Injectable()
export class ScopeGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private scopeService: ScopeService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredScope = this.reflector.get<Scope>(
      'scope',
      context.getHandler(),
    );

    if (!requiredScope) return true;

    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const scopeContext = this.scopeService.extractContext(request);

    return this.scopeService.checkScope(user, requiredScope, scopeContext);
  }
}

// check-scope.decorator.ts
export const CheckScope = (scope: Scope) => SetMetadata('scope', scope);

// Uso en controller:
@Get(':copropiedadId/objetivos')
@CheckScope(Scope.COPROPIEDAD)
async getObjetivos(@Param('copropiedadId') copropiedadId: string) {
  // El guard ya verifico que el usuario tiene acceso a esta copropiedad
}
```

## Testing

- [ ] Scope OWN solo permite acceso a recursos propios
- [ ] Scope COPROPIEDAD verifica membresia
- [ ] Admin de copropiedad A no accede a copropiedad B
- [ ] Residente solo ve datos de su copropiedad
- [ ] Contexto se extrae correctamente del request
