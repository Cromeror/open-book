# OB-002-B-004: Implementar refresh token

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-002 - Gestion de Usuarios y Autenticacion |
| Story | OB-002-B - Autenticacion con JWT |
| Status | pending |
| Priority | high |
| Created | 2025-12-31 |
| Updated | 2025-12-31 |
| Labels | task, jwt, refresh-token, seguridad |
| Depends on | OB-002-B-002 |
| Assigned | unassigned |

## Descripcion

Implementar el sistema de refresh tokens que permite obtener nuevos access tokens sin requerir login. Incluye almacenamiento de refresh tokens en base de datos para permitir invalidacion.

## Contexto Tecnico

### Archivos afectados
- `apps/api/src/entities/refresh-token.entity.ts`
- `apps/api/src/modules/auth/auth.controller.ts`
- `apps/api/src/modules/auth/auth.service.ts`
- `apps/api/src/modules/auth/token.service.ts`

### Enfoque tecnico
Almacenar refresh tokens en BD con referencia al usuario usando TypeORM. Endpoint NestJS para renovar access token usando refresh token valido.

## Criterios de Aceptacion

- [ ] Entidad RefreshToken con TypeORM
- [ ] Endpoint POST /api/auth/refresh creado
- [ ] Acepta refreshToken y retorna nuevo accessToken
- [ ] Refresh token se invalida al usarse (rotacion)
- [ ] Endpoint POST /api/auth/logout invalida refresh token
- [ ] Tokens expirados se limpian periodicamente

## Notas de Implementacion

Entidad RefreshToken con TypeORM:
```typescript
import { Entity, Column, ManyToOne, JoinColumn } from 'typeorm';
import { BaseEntity } from './base.entity';
import { User } from './user.entity';

@Entity('refresh_tokens')
export class RefreshToken extends BaseEntity {
  @Column({ unique: true })
  token: string;

  @Column()
  userId: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;

  @Column({ type: 'timestamp' })
  expiresAt: Date;

  @Column({ type: 'timestamp', nullable: true })
  revokedAt: Date;
}
```

Controller NestJS:
```typescript
@Controller('auth')
export class AuthController {
  @Post('refresh')
  async refresh(@Body() refreshDto: RefreshDto) {
    return this.authService.refreshToken(refreshDto.refreshToken);
  }

  @Post('logout')
  @UseGuards(JwtAuthGuard)
  async logout(@Body() logoutDto: LogoutDto) {
    return this.authService.logout(logoutDto.refreshToken);
  }
}
```

- Implementar rotacion: nuevo refresh token en cada uso
- Detectar reuso de refresh token (posible robo)

## Testing

- [ ] Refresh valido retorna nuevo access token
- [ ] Refresh invalido retorna 401
- [ ] Refresh expirado retorna 401
- [ ] Logout invalida el refresh token
- [ ] Token rotado: el anterior ya no funciona
