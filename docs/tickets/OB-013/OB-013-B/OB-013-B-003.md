# OB-013-B-003: Implementar cola de envío

## Metadata

| Campo | Valor |
|-------|-------|
| Epic | OB-013 - Notificaciones |
| Story | OB-013-B - Notificaciones por email |
| Status | pending |
| Priority | medium |
| Created | 2025-12-31 |
| Updated | 2025-12-31 |
| Labels | task, cola, async |
| Depends on | OB-013-B-001, OB-013-B-002 |
| Assigned | unassigned |

## Descripcion

Implementar cola de procesamiento asíncrono para envío de emails, evitando bloqueos y permitiendo reintentos.

## Criterios de Aceptacion

- [ ] Cola de emails implementada
- [ ] Procesamiento asíncrono
- [ ] Reintentos automáticos
- [ ] Registro de envíos exitosos/fallidos

## Notas de Implementacion

Usando Bull Queue con NestJS (@nestjs/bull):
```typescript
// apps/api/src/modules/notificaciones/processors/email.processor.ts

import { Processor, Process, OnQueueCompleted, OnQueueFailed } from '@nestjs/bull';
import { Job } from 'bull';
import { Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { EmailService } from '../../email/email.service';
import { Notificacion } from '../../../entities/notificacion.entity';

interface EmailJob {
  notificacionId: string;
  to: string;
  subject: string;
  html: string;
}

@Processor('email')
export class EmailProcessor {
  private readonly logger = new Logger(EmailProcessor.name);

  constructor(
    private emailService: EmailService,
    @InjectRepository(Notificacion)
    private notificacionRepository: Repository<Notificacion>,
  ) {}

  @Process()
  async handleEmail(job: Job<EmailJob>) {
    const { notificacionId, to, subject, html } = job.data;

    const enviado = await this.emailService.enviar({ to, subject, html });

    // Actualizar notificación
    await this.notificacionRepository.update(notificacionId, {
      emailEnviado: enviado,
      fechaEmailEnviado: enviado ? new Date() : null,
    });

    if (!enviado) {
      throw new Error('Fallo al enviar email');
    }

    return { enviado: true };
  }

  @OnQueueCompleted()
  onCompleted(job: Job) {
    this.logger.log(`Email enviado: ${job.id}`);
  }

  @OnQueueFailed()
  onFailed(job: Job, err: Error) {
    this.logger.error(`Email falló después de ${job.attemptsMade} intentos:`, err);
  }
}
```

Configuracion del modulo Bull:
```typescript
// apps/api/src/modules/notificaciones/notificaciones.module.ts

import { BullModule } from '@nestjs/bull';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'email',
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 1000,
        },
        removeOnComplete: true,
        removeOnFail: false,
      },
    }),
  ],
  providers: [EmailProcessor, NotificacionService],
})
export class NotificacionesModule {}
```

Función para encolar en el servicio:
```typescript
// En NotificacionService
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';

@Injectable()
export class NotificacionService {
  constructor(
    @InjectQueue('email') private emailQueue: Queue,
    @InjectRepository(Notificacion)
    private notificacionRepository: Repository<Notificacion>,
  ) {}

  private async encolarEmail(notificacionId: string): Promise<void> {
    const notificacion = await this.notificacionRepository.findOne({
      where: { id: notificacionId },
      relations: ['usuario'],
    });

    if (!notificacion) return;

    const template = this.obtenerTemplate(notificacion.tipo, notificacion.datos);

    await this.emailQueue.add({
      notificacionId,
      to: notificacion.usuario.email,
      subject: notificacion.titulo,
      html: template,
    });
  }
}
```

## Testing

- [ ] Jobs se agregan a la cola
- [ ] Emails se envían desde el worker
- [ ] Reintentos funcionan
- [ ] Estado se actualiza en BD
